{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Fitting a piecewise-exponential model (PEM) to simulated data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": false,
    "hidden": true
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO:stancache.seed:Setting seed to 1245502385\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The autoreload extension is already loaded. To reload it, use:\n",
      "  %reload_ext autoreload\n"
     ]
    }
   ],
   "source": [
    "%load_ext autoreload\n",
    "%autoreload 2\n",
    "%matplotlib inline\n",
    "import random\n",
    "random.seed(1100038344)\n",
    "import survivalstan\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from stancache import stancache\n",
    "from matplotlib import pyplot as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The model\n",
    "\n",
    "This style of modeling is often called the \"piecewise exponential model\", or PEM. It is the simplest case where we estimate the *hazard* of an event occurring in a time period as the outcome, rather than estimating the *survival* (ie, time to event) as the outcome.\n",
    "\n",
    "Recall that, in the context of survival modeling, we have two models:\n",
    "\n",
    "1. A model for **Survival ($S$)**, ie the probability of surviving to time $t$:\n",
    "\n",
    "  $$ S(t)=Pr(Y > t) $$\n",
    "\n",
    "2. A model for the **instantaneous *hazard* $\\lambda$**, ie the probability of a failure event occuring in the interval [$t$, $t+\\delta t$], given survival to time $t$:\n",
    "\n",
    "  $$ \\lambda(t) =  \\lim_{\\delta t \\rightarrow 0 } \\; \\frac{Pr( t \\le Y \\le t + \\delta t | Y > t)}{\\delta t} $$\n",
    "\n",
    "\n",
    "By definition, these two are related to one another by the following equation:\n",
    "\n",
    "  $$ \\lambda(t) = \\frac{-S'(t)}{S(t)} $$\n",
    "  \n",
    "Solving this, yields the following:\n",
    "\n",
    "  $$ S(t) = \\exp\\left( -\\int_0^t \\lambda(z) dz \\right) $$\n",
    "\n",
    "This model is called the **piecewise exponential model** because of this relationship between the Survival and hazard functions.  It's piecewise because we are not estimating the *instantaneous* hazard; we are instead breaking time periods up into pieces and estimating the hazard for each piece.\n",
    "\n",
    "There are several variations on the PEM model implemented in `survivalstan`. In this notebook, we are exploring just one of them."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A note about data formatting \n",
    "\n",
    "When we model *Survival*, we typically operate on data in time-to-event form. In this form, we have one record per `Subject` (ie, per patient). Each record contains `[event_status, time_to_event]` as the outcome. This data format is sometimes called *per-subject*.\n",
    "\n",
    "When we model the *hazard* by comparison, we typically operate on data that are transformed to include one record per `Subject` per `time_period`.  This is called *per-timepoint* or *long* form.\n",
    "\n",
    "All other things being equal, a model for *Survival* will typically estimate more efficiently (faster & smaller memory footprint) than one for *hazard* simply because the data are larger in the per-timepoint form than the per-subject form. The benefit of the *hazard* models is increased flexibility in terms of specifying the baseline hazard, time-varying effects, and introducing time-varying covariates.\n",
    "\n",
    "In this example, we are demonstrating use of the standard **PEM survival model**, which uses data in long form. The `stan` code expects to recieve data in this structure."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Stan code for the model\n",
    "\n",
    "This model is provided in `survivalstan.models.pem_survival_model`. Let's take a look at the stan code. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "/*  Variable naming:\n",
      " // dimensions\n",
      " N          = total number of observations (length of data)\n",
      " S          = number of sample ids\n",
      " T          = max timepoint (number of timepoint ids)\n",
      " M          = number of covariates\n",
      " \n",
      " // main data matrix (per observed timepoint*record)\n",
      " s          = sample id for each obs\n",
      " t          = timepoint id for each obs\n",
      " event      = integer indicating if there was an event at time t for sample s\n",
      " x          = matrix of real-valued covariates at time t for sample n [N, X]\n",
      " \n",
      " // timepoint-specific data (per timepoint, ordered by timepoint id)\n",
      " t_obs      = observed time since origin for each timepoint id (end of period)\n",
      " t_dur      = duration of each timepoint period (first diff of t_obs)\n",
      " \n",
      "*/\n",
      "// Jacqueline Buros Novik <jackinovik@gmail.com>\n",
      "\n",
      "data {\n",
      "  // dimensions\n",
      "  int<lower=1> N;\n",
      "  int<lower=1> S;\n",
      "  int<lower=1> T;\n",
      "  int<lower=0> M;\n",
      "  \n",
      "  // data matrix\n",
      "  int<lower=1, upper=N> s[N];     // sample id\n",
      "  int<lower=1, upper=T> t[N];     // timepoint id\n",
      "  int<lower=0, upper=1> event[N]; // 1: event, 0:censor\n",
      "  matrix[N, M] x;                 // explanatory vars\n",
      "  \n",
      "  // timepoint data\n",
      "  vector<lower=0>[T] t_obs;\n",
      "  vector<lower=0>[T] t_dur;\n",
      "}\n",
      "transformed data {\n",
      "  vector[T] log_t_dur;  // log-duration for each timepoint\n",
      "  int n_trans[S, T];  \n",
      "  \n",
      "  log_t_dur = log(t_obs);\n",
      "\n",
      "  // n_trans used to map each sample*timepoint to n (used in gen quantities)\n",
      "  // map each patient/timepoint combination to n values\n",
      "  for (n in 1:N) {\n",
      "      n_trans[s[n], t[n]] = n;\n",
      "  }\n",
      "\n",
      "  // fill in missing values with n for max t for that patient\n",
      "  // ie assume \"last observed\" state applies forward (may be problematic for TVC)\n",
      "  // this allows us to predict failure times >= observed survival times\n",
      "  for (samp in 1:S) {\n",
      "      int last_value;\n",
      "      last_value = 0;\n",
      "      for (tp in 1:T) {\n",
      "          // manual says ints are initialized to neg values\n",
      "          // so <=0 is a shorthand for \"unassigned\"\n",
      "          if (n_trans[samp, tp] <= 0 && last_value != 0) {\n",
      "              n_trans[samp, tp] = last_value;\n",
      "          } else {\n",
      "              last_value = n_trans[samp, tp];\n",
      "          }\n",
      "      }\n",
      "  }  \n",
      "}\n",
      "parameters {\n",
      "  vector[T] log_baseline_raw; // unstructured baseline hazard for each timepoint t\n",
      "  vector[M] beta;         // beta for each covariate\n",
      "  real<lower=0> baseline_sigma;\n",
      "  real log_baseline_mu;\n",
      "}\n",
      "transformed parameters {\n",
      "  vector[N] log_hazard;\n",
      "  vector[T] log_baseline;     // unstructured baseline hazard for each timepoint t\n",
      "  \n",
      "  log_baseline = log_baseline_mu + log_baseline_raw + log_t_dur;\n",
      "  \n",
      "  for (n in 1:N) {\n",
      "    log_hazard[n] = log_baseline[t[n]] + x[n,]*beta;\n",
      "  }\n",
      "}\n",
      "model {\n",
      "  beta ~ cauchy(0, 2);\n",
      "  event ~ poisson_log(log_hazard);\n",
      "  log_baseline_mu ~ normal(0, 1);\n",
      "  baseline_sigma ~ normal(0, 1);\n",
      "  log_baseline_raw ~ normal(0, baseline_sigma);\n",
      "}\n",
      "generated quantities {\n",
      "  real log_lik[N];\n",
      "  vector[T] baseline;\n",
      "  real y_hat_time[S];      // predicted failure time for each sample\n",
      "  int y_hat_event[S];      // predicted event (0:censor, 1:event)\n",
      "  \n",
      "  // compute raw baseline hazard, for summary/plotting\n",
      "  baseline = exp(log_baseline_mu + log_baseline_raw);\n",
      "  \n",
      "  // prepare log_lik for loo-psis\n",
      "  for (n in 1:N) {\n",
      "      log_lik[n] = poisson_log_log(event[n], log_hazard[n]);\n",
      "  }\n",
      "\n",
      "  // posterior predicted values\n",
      "  for (samp in 1:S) {\n",
      "      int sample_alive;\n",
      "      sample_alive = 1;\n",
      "      for (tp in 1:T) {\n",
      "        if (sample_alive == 1) {\n",
      "              int n;\n",
      "              int pred_y;\n",
      "              real log_haz;\n",
      "              \n",
      "              // determine predicted value of this sample's hazard\n",
      "              n = n_trans[samp, tp];\n",
      "              log_haz = log_baseline[tp] + x[n,] * beta;\n",
      "              \n",
      "              // now, make posterior prediction of an event at this tp\n",
      "              if (log_haz < log(pow(2, 30))) \n",
      "                  pred_y = poisson_log_rng(log_haz);\n",
      "              else\n",
      "                  pred_y = 9; \n",
      "              \n",
      "              // summarize survival time (observed) for this pt\n",
      "              if (pred_y >= 1) {\n",
      "                  // mark this patient as ineligible for future tps\n",
      "                  // note: deliberately treat 9s as events \n",
      "                  sample_alive = 0;\n",
      "                  y_hat_time[samp] = t_obs[tp];\n",
      "                  y_hat_event[samp] = 1;\n",
      "              }\n",
      "              \n",
      "          }\n",
      "      } // end per-timepoint loop\n",
      "      \n",
      "      // if patient still alive at max\n",
      "      if (sample_alive == 1) {\n",
      "          y_hat_time[samp] = t_obs[T];\n",
      "          y_hat_event[samp] = 0;\n",
      "      }\n",
      "  } // end per-sample loop  \n",
      "}\n"
     ]
    }
   ],
   "source": [
    "print(survivalstan.models.pem_survival_model)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This may seem pretty intimidating, but once you get used to the [Stan language](http://mc-stan.org/documentation/) you may find it's pretty powerful. \n",
    "\n",
    "One of the goals of [survivalstan]() is to allow you to edit the stan code directly, if you choose to do so. Or to reference Stan code for models others have written. This expands the range of what [survivalstan]() can do."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Simulate survival data "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In order to demonstrate the use of this model, we will first simulate some survival data using `survivalstan.sim.sim_data_exp_correlated`. As the name implies, this function simulates data assuming a constant hazard throughout the follow-up time period, which is consistent with the Exponential survival function.\n",
    "\n",
    "This function includes two simulated covariates by default (`age` and `sex`). We also simulate a situation where hazard is a function of the simulated value for `sex`. \n",
    "\n",
    "We also center the `age` variable since this will make it easier to interpret estimates of the baseline hazard.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO:stancache.stancache:sim_data_exp_correlated: cache_filename set to sim_data_exp_correlated.cached.N_100.censor_time_20.rate_coefs_21453428780.rate_form_1 + sex.pkl\n",
      "INFO:stancache.stancache:sim_data_exp_correlated: Starting execution\n",
      "INFO:stancache.stancache:sim_data_exp_correlated: Execution completed (0:00:00.024619 elapsed)\n",
      "INFO:stancache.stancache:sim_data_exp_correlated: Saving results to cache\n"
     ]
    }
   ],
   "source": [
    "d = stancache.cached(\n",
    "    survivalstan.sim.sim_data_exp_correlated,\n",
    "    N=100,\n",
    "    censor_time=20,\n",
    "    rate_form='1 + sex',\n",
    "    rate_coefs=[-3, 0.5],\n",
    ")\n",
    "d['age_centered'] = d['age'] - d['age'].mean()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Aside: In order to make this a more reproducible example, this code is using a file-caching function `stancache.cached` to wrap a function call to `survivalstan.sim.sim_data_exp_correlated`. *"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Explore simulated data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here is what these data look like - this is `per-subject` or `time-to-event` form:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>age</th>\n",
       "      <th>sex</th>\n",
       "      <th>rate</th>\n",
       "      <th>true_t</th>\n",
       "      <th>t</th>\n",
       "      <th>event</th>\n",
       "      <th>index</th>\n",
       "      <th>age_centered</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>39</td>\n",
       "      <td>male</td>\n",
       "      <td>0.082085</td>\n",
       "      <td>14.798745</td>\n",
       "      <td>14.798745</td>\n",
       "      <td>True</td>\n",
       "      <td>0</td>\n",
       "      <td>-16.33</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>47</td>\n",
       "      <td>female</td>\n",
       "      <td>0.049787</td>\n",
       "      <td>2.613670</td>\n",
       "      <td>2.613670</td>\n",
       "      <td>True</td>\n",
       "      <td>1</td>\n",
       "      <td>-8.33</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>53</td>\n",
       "      <td>female</td>\n",
       "      <td>0.049787</td>\n",
       "      <td>81.586870</td>\n",
       "      <td>20.000000</td>\n",
       "      <td>False</td>\n",
       "      <td>2</td>\n",
       "      <td>-2.33</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>54</td>\n",
       "      <td>male</td>\n",
       "      <td>0.082085</td>\n",
       "      <td>17.647537</td>\n",
       "      <td>17.647537</td>\n",
       "      <td>True</td>\n",
       "      <td>3</td>\n",
       "      <td>-1.33</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>49</td>\n",
       "      <td>male</td>\n",
       "      <td>0.082085</td>\n",
       "      <td>6.346437</td>\n",
       "      <td>6.346437</td>\n",
       "      <td>True</td>\n",
       "      <td>4</td>\n",
       "      <td>-6.33</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   age     sex      rate     true_t          t  event  index  age_centered\n",
       "0   39    male  0.082085  14.798745  14.798745   True      0        -16.33\n",
       "1   47  female  0.049787   2.613670   2.613670   True      1         -8.33\n",
       "2   53  female  0.049787  81.586870  20.000000  False      2         -2.33\n",
       "3   54    male  0.082085  17.647537  17.647537   True      3         -1.33\n",
       "4   49    male  0.082085   6.346437   6.346437   True      4         -6.33"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "d.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*It's not that obvious from the field names, but in this example \"subjects\" are indexed by the field `index`.*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can plot these data using `lifelines`, or the rudimentary plotting functions provided by `survivalstan`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x7f39e153b950>"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAg0AAAFoCAYAAADUycjgAAAABHNCSVQICAgIfAhkiAAAAAlwSFlz\nAAAPYQAAD2EBqD+naQAAIABJREFUeJzs3XlYXOXZ+PHvLOwwZNiGHQKBk4TsZN/MYl1aa7Xur2u1\nttq+avWt1tpf1dpWW31rq23Vt9UatZu1tpqqcTcazQoJIQlwEsK+DWHfYbbfHwMYSGKADAxzuD/X\nleuSM+fMueF2nnPPeZ7zPDqXy4UQQgghxOnovR2AEEIIIXyDFA1CCCGEGBEpGoQQQggxIlI0CCGE\nEGJEpGgQQgghxIhI0SCEEEKIEZGiQQghhBAjIkWDEEIIIUZEigYhhBBCjIgUDUIIIYQYEeNoD1AU\nZQ1wN5ANxAEXqaq6+TTHrAN+BWQBFcDPVVV9YdTRCiGEEMJrxnKnIQTIA74DnHbhCkVRUoE3gA+A\n+cATwLOKonxpDOcWQgghhJeM+k6DqqpvA28DKIqiG8EhtwIlqqreM/AWiqKsBu4E3hvt+YUQQgjh\nHRMxpmE58P6wbe8AKybg3EIIIYTwkIkoGmIB67BtVsCkKErABJxfCCGEEB4w6u4Jb7n85VtPO37i\ndAKMAWTHzWFFcjYLY7PwN/p7IjQhhBBishvJcILTmoiioQ6wDNtmAdpUVe0d6ZvMClyO3eHE5Rpa\nOzS19WJt6gJgzfw4oqcFDXm9ra+DvPqDtPa20WvvZXtlLtsrcwkw+DMvejbZlvlkRc3E3+A3lt9N\njIHBoMdkCqKtrRuHw+ntcMQZknxqj+RUWwby6QkTUTTsAM4ftu2c/u0j9pOvXU9zcyd2+9D/gTu6\nbdz3h510dNs43BfCVd9YgtEwtNfl0hkXUtJazt76/eyrP0BbXzu9jj721OWxpy6PAIM/c6NmszBm\nHrMjFCkgJojD4Twhn8J3ST61R3IqhtMN/+Z+OoqihAAzcN/q2AvcBXwENKmqWqkoyiNAvKqq1/fv\nnwocAJ4C/gRsBH4DfFlV1eEDJL+I62RFA8An+2vYtKUIgCs3zOCcpcmnfBOny8nRljL21uez71g+\n7X0dQ14fKCAW9RcQflJAeJzRqMdsDjlpESh8j+RTeySn2tKfT691TyzGXSS4+v/9qn/7C8CNuAc+\nJg3srKpqmaIoXwF+DdwOVAE3jbJg+EKr58XxcV4NpbVtvPZpKUtnW5gWevIxlnqdngxzGhnmNC7L\nvJCjLaXuAqL+AO22DnodfeRY88ix5hFoCDjuDkSmFBBCCCGmtFHfafCiU95pACitbeNnL+TgAlZk\nWbj5q1mjenOny0lxfwGR119AHM9dQGSxKGYus6SAOCPyLUZbJJ/aIznVFk/eadBM0QDwwttFfJxX\nA8C9Vy8iM2namE7kLiBKyO0vIDpsnUNeDzQEMjdqNtmWecyKyMSo95mHUCYFaZC0RfKpPZJTbZGi\n4RQ6um388P920NljJykmlAe+sQS97sz+Tg6no/8OxH7yjh08oYAw+YexNmElaxKWE+ofckbnmiqk\nQdIWyaf2SE61RYqGL/Dh3ir+/O5hAG6/ZB4LMqI8FoDD6eBISwl76/PZP6yA8NMbWWJZxPqk1cSH\nxnrsnFokDZK2SD61R3KqLVI0fAGb3ckPntlOS0cf6fEm7rs2G90Z3m04GYfTQUGTykeVn6I2Fw95\nbaY5g/VJq5kdqaDXyerjw0mDpC2ST+2RnGqLt5+emNT8jHrOW5rM3z8s5mhNG2pFCzNTzB4/j0Fv\nYG7UbOZGzaa6o5aPKj9lj3UfdqedouYjFDUfISY4ivWJq1kWt5gAg8w+KYQQwrdp7k4DQE+fnbuf\n2k5nj52s6RH8zxULJiA8aO/r4NPqnXxcvX3I/A9BxiBWxy/jrMSVmAPHNjhTS+RbjLZIPrVHcqot\n0j0xAq9/Wsrrn5YCcP8Ni0mNNY1nbEPYnHb2WvfzYeU2qjpqBrfrdXoWRs9lfdJqpoenTFg8k400\nSNoi+dQeyam2SNEwAh3dNu5+aju9NgfZSjTfvXjuOId3IpfLRXFLKR9VbiO/oQAXn/+tU03JrE9a\nzcLouRj0hgmPzZukQdIWyaf2SE61xZNFg2ZH6YUG+bFuYTwAe9Vj1DZ2nuYIz9PpdGSY0/jWvOt5\ncMU9rE9aTaDBPVNlWVsFzx/6K/fv+AXvV3yM0yUfTCGEmGi//OXP+fKXN7J27VKKi494JYa6ulrW\nrFnitfOPhmaLBoBzliRjNOhwAe/srvRqLFFBkVyacSE/W/UjLs24kMjACABaelv5d/GbfFDxiVfj\nE0KIqWbnzu28886bPPbYE7z++tukpaV7LZbxeMpvPGi6aDCHBbBslntV7t2FVnr7HF6OCIKMgaxP\nWs2DK+7hW3OvIybIPY/E9trdJyz7LYQQYvxUV1cSGRlFVtYczOYI9HrvXRJ9pf3X3COXw62ZH89n\nB+vo6XOQe7ielXPivB0S4B4UOT96Dl22bv5c9Ar1XQ1UtleTbEr0dmhCCHFGunrs1DZNbJdwXEQI\nwYEjv6Q9/PBP2LLlDXQ6HWvWLCE2Np5XXnmdl156ns2bX6OpqYHk5BSuv/4m1q3bCMC+fbncfvst\n/OpXv+WZZ35LeXkZc+bM58EHf05RUQG///1vOHasnpUr13DvvT8mIMDdHb1r1w5eeOE5SkqOYjDo\nycqaxx13/A8JCadu70tKinnqqSfZvz+PoKAglixZxu2330V4uHefwNN80ZCRGE6MOYj65m4+za+d\nNEXDgAUxc/j74X9jd9rZY90nRYMQwqd19di55+ntdPXaJ/S8wQFGHr115YgLh+997/vExyfwn/+8\nxrPPvoRer+OFF57jvffe4Z577iMxMYm8vL389Kf3YzZHMH/+wsFjn3/+D9x1170EBATw4x/fy/33\n34u/fwAPPvgwXV2d3Hff93n11Zf5r/+6DoCenm6uvPIaZszIoKuri+eee4b77rubF17420lj6+jo\n4I47vsOFF17MHXd8n56eHp5++rfcf/99PPHEU2f+xzoDmu6eAHc/0eq57kKhqKKF+pZuL0c0VJAx\niDmRswDItebJgEghhJgAwcEhBAeHoNcbMJvNBAeH8Oc/b+KHP7yfJUuWERcXz/nnX8A555zP66//\na/A4nU7HzTd/hzlz5pKRkckFF1zI/v37uPvuHzJjRgbz5i1g3bqN7N2bM3jMWWdtYO3adcTHJzBj\nRgY/+MGPKSkpprS05KSxvfrqy2RmzuTmm28lKSmZjIxM7r33/7F37x6qqrw7Pk/zdxoAVs6J5d/b\nSnC5YPuBWi5ak+btkIZYYllA3rEDtPa1c6S5BCVihrdDEkKIMQkOdH/jn+zdE8NVVVXS09PDnXd+\nd8j4AofDTmbmzCH7pqd/3kZHREQSEBBIbOznd7HN5ggKCwuGvPezzz5DQcFBWltbcDpd6HQ6rNY6\npk8/8XpUXHyEvXv38KUvrR2yXafTUV1dRWJi0ph/zzM1JYqGCFMgWakRHCxt4rMDtVy4evoZr37p\nSVmRMwk0BNLj6CHHuk+KBiGETwsONJIeH+7tMEalu7sLgMcee4KoqKELHfr7D10GwGj8/NKp0+mG\n/DywzXXcXeN77vkecXEJ3Hvvj4mKisLpdHHttZdjt9tOGcuqVWv5znduP2GA5PDYJprmuycGrJ7n\nrgIb23o5cLTRy9EM5WfwY0HMHAD2HTuAzTmxfYFCCDHVpaam4efnj9VaS0JC4pB/0dExY37ftrZW\nKisruP76G1m0aDHJyam0trZ+4TGZmTMpKyshNjbuhFgCAgLHHIsnTJmiYWFGNCH9t66efu0g2/bX\nTKpHXJZY3INsuu09bKva7uVohBBiagkODuaqq67hyScfZ8uWN6iuruLw4SJeffVl3n77zcH9Rnvd\nCAszER4ezubN/6a6uorc3D387ne//sJ5Gb7+9ctpa2vjgQfuo6iogOrqKnbt2sHDD//E69etKVM0\n+Bn1XHfeTIwGPX12J89vKeLZNwrp6Zsc3+ozzekkh7mfnHiz9D1aer+4EhVCCOFZN998KzfccBN/\n+csLXHvt5Xz/+3ewY8dnxMUlDO4z2kmYdDodP/nJI6hqIddddwW/+92v+e///t5J9xsQFRXF008/\nh8vl5K67buOGG67it7/9NWFhJq9PAqXZtSdOpbyunadfP0h9s/spirjIYG69aA6J0aGeiPGMlLdV\n8ljO73DhIjtmPjfOudrbIY0LmddeWySf2iM51RZZe+IMpMSG8cANS1gy091HVdvYxc9eyGFbfs1p\njhx/KaYkVicsByC3fj9FTZN/HnIhhBBTx5QrGgCCAozc8rUsrj0nE6NB5+6ueKuI594o8PpU0xem\nnUuoXwgA/zj8mgyKFEIIMWlMyaIB3P1H6xcl8qNrFxMzLQiAzw7W8dALe6g+1uG1uIL9grl4xlcA\nsHYd40NZyEoIIcQkMWWLhgEpsWHcf8MSFh/XXfHTF3L4NL/WazEti80mPTwVgC1lH9DY3eS1WIQQ\nQogBU75oAPdEJLd+LYtrjuuu+NNbhfzq5TxyiuqxOyZ2IJBOp+MK5WL0Oj02p41/Fb95+oOEEEKI\ncTYlZoQcCZ1Ox4ZFiaTFm3j6tYMca+nhUGkTh0qbCA3yY0VWLGvmxZEYMzFPWSSExrE6fjmfVG/n\nQEMBTpcTvU5qPCGEEN4jV6FhUmNNPHDDUi5YmYo5zL2saUe3jfdyKrn/T7t5aNMePtpbRVfPyaf/\n9KTp4ckAOFwOOm1d434+IYQQ4ovInYaTCA408vW1aVy0ejoFZU1sy69l35Fj2B0uyuraKatr5+8f\nFpOdGc3qeXHMTDGPy1oW4f6mwf9u7W0jzN/7c0kIIYSYusZUNCiK8l3g+0AssB+4TVXVPafZ/7tA\nKlAOPKyq6ktjOfdE0ut1zEmLZE5aJB3dNnYeqmNbfi2V9R3Y7E52FljZWWAl0hTIqrmxrJ4bR1T/\nkxieEB5wXNHQ10Yi8R57byGEEJ738MM/oaOjg4cffszboYyLURcNiqJcAfwK+BawG7gTeEdRlExV\nVRtOsv+twM+BbwI5wDLgj4qiNKmq6jMj/EKD/Dh7cRJnL06ivK6dT/Nr2VlQR2ePnca2HjZ/Vsbm\nz8qYlWJmzfw4FmVE4+9nOKNzDikaetvO9FcQQgghzshY7jTcCfyfqqovAiiKcgvwFeBG4NGT7H9N\n//7/7P+5TFGUJcAPAJ8pGo6XEhtGSmwYl29IZ9+RBrbl11JQ2oQLKCxvprC8meAAI8uyLKyZF0eK\nJWxM84UHGgLwN/jT5+iTokEIIYTXjapoUBTFD8gGHh7YpqqqS1GU94EVpzgsAOgZtq0HWKooikFV\nVe9OwXgG/IwGls6ysHSWhcbWHj47WMun+bU0tPbQ1Wvno73VfLS3msToEFbPi2flnFhCg/xG/P46\nnY5p/ibquxtkASshhPCw2277NunpM9Dr9WzZ8iZ+fn5861u3cvbZ5/H4479k69YPiYiI4Hvfu5vl\ny1fidDp59NGfk5ubQ1NTAxZLLBdffBmXXXblKc/hcrn48583sXnzazQ1NZCcnML119/EunUbJ/A3\n9ZzR3mmIAgyAddh2K6Cc4ph3gG8qivK6qqp7FUVZDNwE+PW/3/D3OiWDYfI+7GGJDObrZ6Vz0do0\nisqb+SSvhpyievrsTqqOdfL3D47w0d4qHvrmMoICRv5nnxboLhpa+9owGifv7z8aA3mczPkUIyf5\n1J4zzWm3rZu6znpPhnRasSExBPmNbkyZTqfj7bff5Jprruf551/i/fff5bHHfsEnn2xl3boN3Hjj\nN/nb3/7Mz352P6+/vgWDwUBsbCy/+MVjmEwmDhzI5xe/+BkWSwwbNpzd/57ufwPt9fPPP8u7777N\nD3/4/0hMTCIvby8//ekDREVFsmDBIo//HU7Gk5/NiXh64qeABdihKIoeqAM2AfcAo5o1yWTy3CDD\n8bQqIpRVC5Po7LaxLa+a93aXc7iiBWtzNwUVLZy9NGXE75Vsjudwcwll7ZWETwvS1FwNvpJPMTKS\nT+0ZS067+rq5642H6bR1j0NEpxbiF8TvL/g5wf4jj9lo1DNr1izuvPN2ALKyMnnxxeexWKK5/nr3\nKsNxcd/jX//6J/X1VcybN4+7775r8PjZszM4fLiATz75kEsu+RoAAQF+9PUZMZtD6Ovr46WXNrFp\n0ybmz5/ff44MCgsP8Oabr7N+/RpP/foTZrRFQwPgwF0EHM+Cuxg4gaqqPbjvNHy7f79a4NtAu6qq\nx0Zz8ra2bhwTPDvjmVo2M5qlShQ/eHoHdU1dvLerguyMqBEfnx6Wxvt8SntvB/vLD5ManjSO0U4M\ng0GPyRTkk/kUJ5J8as+Z5LTb1o3LNU6BfQGXC1paOun1G3m8druTtLR0mps7B7eZTOEkJqYObjMY\n3EVIeXk1SUnp/POfL/PGG5uxWuvo7e3FZrORmakM7t/ba6Ovz05zcyelpSV0d3dzww3fAFzHndc+\n5JjxNpBPTxhV0aCqqk1RlFxgI7AZQFEUXf/PT57mWAdQ03/MlcB/Rhusw+H02bXdl8+28NqnpRSW\nNdHQ0s200IARHTfDlI5ep8fpcnLwWBGJIQnjHOnE8eV8ihNJPrVnLDn10wXw0Mp7qesc1XfCMxYb\nEo2fLmBU8bpcLgwGw5BjdDoder3hhPex2x28887b/Pa3v+G22+4iK2suwcHB/PWvL1JYeGhwf5fL\n/c9ud9Le7l788LHHniAqauiXRX9/f5/8vIyle+JxYFN/8TDwyGUw7i4HFEV5BIhXVfX6/p8zgKXA\nLiACuAvIAq470+B9ybIsd9HgAnYXWDlnafKIjgv2C2K6KZmjrWUUNKqcl+qbg2eEEFNHkDFocEZb\nLTlwYD9z587noosuGdxWXV11yv1TU9Pw8/PHaq1l/vwFExHiuBt1B7mqqv/APbHTQ8A+YB5w7nFd\nDbHA8ffQDcD/AHm4B0X6AytVVa04g7h9jsUczPQ497wLOwtGPPYTgNmR7jGmpW0VdE1wP6EQQgi3\nxMQkiooK2b17J5WVFTz77DMUFRWccv/g4GCuuuoannzycbZseYPq6ioOHy7i1Vdf5u23fXLGgbEN\nhFRV9SngqVO89o1hPxcBEzNEdJJbnmWhtLaNsrp26pq6iI0IHtFxsyIy+U/JOzhdTtTmYhbGzB3n\nSIUQQvtOPn/Oidvc++m46KJLOXLkMA88cB86nY6zzz6Hiy++jF27tp/yHDfffCtms5m//OUFHnvs\nYUJDw8jMVLj22hs994tMIJ3LGyNWxsbV3Nzpk31AA1o7ernr95/hcsGFq1K5aE3aiI5zupz88NOf\n0mHrZGXcUq6edek4Rzq+jEY9ZnMIvp5P4Sb51B7Jqbb059MjCyRp5/k9HxAeGsDs1AgAdh6yMtKC\nTa/TMysiE4ADjQXYnPZxi1EIIYQ4FSkaJtjKrFgA6lu6OVzZMuLjsi3uZ3zb+zrYVZszLrEJIYQQ\nX0SKhgmWrUQPzgj5yf7aER+XFTmT+BB3wfFe+VYcTp+dfVsIIYSPkqJhgvn7GVg22z03Vq5aT1fP\nyLoa9Do956VuAKChp4nc+v3jFqMQQghxMlI0eMGaeXEA9Nmd7C4c+eOXC2PmERPsniDknbIPcbpk\ngJIQQoiJI0WDF6TGhpEYHQrAtvyaER+n1+k5J3k9AHVd9ew/dmhc4hNCCCFORooGL9DpdIN3G0pr\n26mq7xjxsUtjF2EOmAbAO2UfjPgJDCGEEOJMSdHgJSvmxGI0uB+b/WQUdxsMegPnpKwDoLKjhkON\nReMRnhBCCHECKRq8JDTIjwUZ0QDkHWkY1bEr4pZg8g8D4JUjm+mx93g8PiGEEGI4KRq8aHqs+8Lf\n3N6LcxTdDH4GPy5K/zIADd2N/OPw6+MSnxBCCHE8KRq8yBzmXh7b4XTR3tk3qmOXxi5iscW9atqu\nulxy6vZ5PD4hhBDieFI0eNFA0QDQ1N47qmN1Oh1XKhcTGWgG4G/qv2nsbvJofEIIIcTxpGjwoghT\n4OB/N7WNrmgA95r1N2RdhQ4dPY4eNhX8TWaKFEIIMW6kaPCiaaHH32kY22DGtPBUvjz9bABKWsvZ\nUvaBR2ITQgghhpOiwYv8jHpMwX6AezDkWJ2bsoH08FQA3i77gOKWUk+EJ4QQQgwhRYOXmcPcXRRn\nUjQY9Aaun30VQcZAXLjYdOhvdPR1eipEIYQQApCiwetMIf4AtHeN7umJ4SKDzFylXAJAc28Lfzjw\nIjbnyBbDEkIIIUZCigYv07knhcQTs0FnW+azIWkNAEdbS/lb0asyzbQQQgiPkaLBy/QDVYOHXDzj\nK8yJnAm45294t/wjj76/EEKIqUuKhknCU3cE9Do938j6LxJC3QtibS55m731+R55byGEEFObFA1e\n5uEbDQAEGgO5Zd4NhPm7l99+seDvlLdVev5EQgghphQpGiYJp4eHHkQEmrll3g346Y3YnHaeyd9E\nc0+LZ08ihBBiSpGiwct0nhwJOUyqKZlrZ10BQFtfO0/nP0+PfeyPdgohhJjapGjwsoHeCYenbzX0\ny7bM54Lp5wJQ3VHLU/ufo62vfVzOJYQQQtukaPCyaHMQAKW17TS0do/LOc5L3cDS2EUAHG0t45d7\nnqSirWpcziWEEEK7pGjwsvULE9DpwOly8e6e8RmsqNPpuGbmZWxMXgtAS28rj+99il21ueNyPiGE\nENokRYOXRU8LYsnMGAA+2V9DR7dtXM5j0Bv4+owLuGH2VYODI18sfJlXj/xHVsYUQggxIsaxHKQo\nyneB7wOxwH7gNlVV93zB/lcDdwMZQCuwBbhbVdWmsZxfa85flsLuwnr6bE4+2lfNV1emjtu5lsQu\nxBISzR/yX6S5t4UPK7dR1VHLTVlXE+ofMm7nFUII4ftGfadBUZQrgF8BDwALcRcN7yiKEnWK/VcB\nLwB/BGYDlwJLgT+MMWbNSYkNY1aKGYAPcirps43vN//ksER+sOR2MqalAXC4uZhf5jxJZXvNuJ5X\nCCGEbxtL98SdwP+pqvqiqqpFwC1AF3DjKfZfDpSqqvp7VVXLVVXdDvwf7sJB9Dt/eTIAbV02th+s\nG/fzhfmHctuCm1mfuBqApp5mfpX7e3KseeN+biGEEL5pVEWDoih+QDbwwcA2VVVdwPvAilMctgNI\nUhTl/P73sACXAW+OJWCtykqNICnGPYPj27srcI7TI5jHM+gNXJp5IdfMuhyj3ojNaeP5Q3/lteK3\ncLqc435+IYQQvmW0YxqiAANgHbbdCignO0BV1e2KolwDvKwoSmD/OTcD/z3Kc2MwaHvc5ldWpvLM\nawepb+6mqLKFeemRE3LeNUlLSTTF8kzeC7T0tvJexVbabe1cl3U5Br3B4+cbyKPW8zlVSD61R3Kq\nLZ7M45gGQo6GoiizgSeAB4F3gTjgf3F3UXxzNO9lMgV5OrxJ5ZwV03nujQJsdic1Td2ctXjiBiaa\nzbN41PJD/vezP3C4sYSdtblgdHH78hsxjkPhANrP51Qj+dQeyakYbrRFQwPgACzDtluAU3XE3wt8\npqrq4/0/H1QU5TvANkVRfqSq6vC7FqfU1taNw6Ht2+aJ0aGU1rahljXS3Nw5wWc38t/zb+L3ec+j\nNhWzs3Iv3T293Dz/Wvz0nqsvDQY9JlPQlMjnVCD51B7JqbYM5NMTRnUlUFXVpihKLrARdxcDiqLo\n+n9+8hSHBQN9w7Y5ARefz6I8Ig6HE7td2/8DJ1vcRUNZbZtXflcDftwy9xv88cCLFDSp7D92iKf2\nPc/Nc67D3+Dn0XNNhXxOJZJP7ZGciuHG0tHxOHCzoijXKYoyE3gGd2GwCUBRlEcURXnhuP3/A1yi\nKMotiqJM738E8wlgl6qq4/+YgI9JtoQB0NjWO24TPZ2Ov8GPb827nrlRswEoaFR5Jv95eh3Daz8h\nhBBTyaiLBlVV/4F7YqeHgH3APOBcVVWP9e8SCyQdt/8LwF3Ad4EDwMtAIXDJGUWuUSn9RQNAudV7\nC0v56Y3cPOdaFsbMA0BtLub3ec/RY+/xWkxCCCG8S+cahyWZx4mrublT87fK+mwOvvP4JzhdLi5b\nn875y1K8Go/D6eClwn+wx7oPgOmmZL4z/yaC/cbeP2Y06jGbQ5gK+ZwKJJ/aIznVlv58jmo4wKnI\n8zSTjL+fgbioYABKatq8HI17LofrZl/BirglAJS2VfBk3h/oso3PipxCCCEmLykaJqHpsSYActVj\n/OmtQnr7vLuglF6n579mXsKaBPf8XZXt1fzp0F9koSshhJhipGiYhL6yMoUIUwAAn+bX8uCmPZTX\neW98A7gLhysyL2JV/DIACpsO89rRt7wakxBCiIklRcMkZDEH85Mbl7K4f8lsa1MXP3sxh7d3VeD0\n4hgUnU7HFZkXDS509WHlNnbUnHJxUyGEEBojRcMkFRLox61fy+KG82fi76fH4XTxj4+K+fU/9tPa\n0eu1uAx6A9+ccy2Rge5VOf+u/ouS1jKvxSOEEGLiSNEwiel0OtbOj+eBG5aQbHEvZnWotIn7/7Sb\n/KMNXosr1D+Eb8+7AX+DP3aXgz/kv0hTT7PX4hFCCDExpGjwAXGRIfzo2sWcu9Q9/UV7l43fvJLP\nX98/jM3uncGICaFx3DD7Snc8tg7+kP8CfTL5kxBCaJoUDT7Cz6jnig0Z3HX5fEwh/gC8n1PFz17M\npaZhoteocJsfPYcLpp8LQGVHDS8V/gMfmvdDCCHEKEnR4GPmpEXy0I1LmZvmXja7sr6Dhzbt4ZWt\nxbR4YazDeakbBmeN3Fufz9aqzyY8BiGEEBNDigYfZArx53uXzeOqszMwGnT02Z1s2VnBPU9v54W3\ni7A2d01YLDqdjutmXU5ssPtJj7xjBybs3EIIISaW59Y7FhNKp9PxpcVJzEo28+9tJew70oDd4eLj\nvBo+2V9DthLDl5cnk9o/UdR48jf4ExcaS11XPU6XTDkrhBBaJUWDj0uMCeW2S+ZR09DJ27sq2HGo\nDofTRU5RPTlF9WSlmjl/eQqzUszodB6ZelwIIcQUJUWDRsRHhXDjV2Zx0ZrpvLunko/zaui1OThU\n1syhsmaoQFyUAAAgAElEQVRSY8P48vIUFmVGo9d7vngYeEcZBymEENolRYPGRJgCuXJjBhesTOXD\nvVW8n1NFR7eNsrp2nnrtIBZzEOcvT2FFVix+Rs8NadF9XjZ47D2FEEJMLlI0aFRokB8XrprOuUuS\n2ZZfwzu7K2ls68Ha3M2mLUX8e1sJ5yxJYt2CBIIC5H8DIYQQpydXC40L8Ddw9uIk1i1MYE9hPW/t\nKqf6WCetHX288tFR3thezoZFCaxbkECEKeCMxz3IfQYhhNAuKRqmCKNBz4o5sSzPspB/tJG3dpZz\npKqV7l47b+4o580d5YQF+5FsCSPZEkqKJYxkSxgx5iD0IygkBoqNHkcvLpdLBl0KIYQGSdEwxeh0\nOubPiGL+jCiOVLWwZWcFecXudSzau2wcKm3iUGnT4P4BfgaSYkJJtoSSbAkjxRJGfFTICeMh4kIs\nANR1WtlWvZO1iSsm7pcSQggxIaRomMIyEqeRcek0rM1dHKlspcLaTkV9B5X17XT3ute06LU5KK5u\npbi6dfA4g15HfFTIkEJiRcwK9ljzqOu08q/i/zBj2nTiQ2O99asJIYQYBzofWivA1dzcid0ukweN\nN6fLRUNLNxXWDsqt7VRYO6iwttPa+cULUkXG9NGdshWXzkmEXzR3zL+VKFPoCfsZjXrM5hAkn9og\n+dQeyam29OfTI33GUjSIEWvt6KW8v4AYuCtR39w9ZB+DpQz/lCIA7HXJBDcuGDZOIpTYqBAiI0Kl\nQdIIucBoj+RUWzxZNEj3hBix8NAA5oUGMC89cnBbd6+dyvqBOxLtlFtDONbSiH7aMYyxFbS3RnGg\nJIYDJY2DxwQFGEhLmEZCZDCJ0e7xEvFRIRgNshSKEEJMZnKnQXhcU1cbv9jzazodnRhdgUTVnUNN\nnYNem+OUxxgNOhKihg64TIwJIdBf6trJTr6Vao/kVFuke0JMeoWNh/nd/mcBmGnO4Nb5N9LQ0kuF\ntZ3KYx3UNHRRXNVCe5ftlO+hA2Iigknp79rISJpGamyY3JGYZOQCoz2SU22RokH4hH8deYMPKj8B\n4PzUjVyQdi7weYPU1NRBQ0vPYNfGwIDLhtaeU75ngL8BJWkas1LMzEoxkxgTOqJ5JMT4kQuM9khO\ntUXGNAif8NX08yhuKaW8vZItZR8QGxzD4tiFg6/rdDrMYQGYwwJYMCNqcHtXj22wgCi3dlBR305t\nQxdOl4vePgf5RxvJP+oeIxESaGRmfwExK8VMbESwTCwlhBDjRO40iHHV0tvKo3t+S2tfG0a9ke8t\n/DYZkdNH/S2mu9fOkaoWCsqaKSpvpqK+46T7TQv1Z1aKebCQiAoP8uSvI05CvpVqj+RUW7zePaEo\nyneB7wOxwH7gNlVV95xi3+eB63EvS3B80IdUVZ07itNK0eCjKtqqeHzv09icNsL8Q7lv2R2kxyee\nUYPU3tWHWtFCYUUzhWXN1DV1nXS/6GmBzEqJGCwkwkP8z+RXESchFxjtkZxqi1eLBkVRrgBeAL4F\n7AbuBC4DMlVVbTjJ/mHA8V/3jEA+8ISqqj8dxamlaPBh++oP8OzBlwBIDIvn4S/dTXeHw2P5bG7v\npai8mcLyZgrLm2hs6z3pfglRIYN3IWYmTyM40M8j55/K5AKjPZJTbfF20bAT2KWq6h39P+uASuBJ\nVVUfHcHxFwH/BKarqlo5ilNL0eDj3i77gP+UvAPA4vh53JR1Dc5TP4U5Zi6Xi2OtPRSVN1NQ1kRR\neTNtJ3lKQ6eDFEvY4HiIjMRpBPgbPB+QxskFRnskp9ritYGQiqL4AdnAwwPbVFV1KYryPjDSFYpu\nBN4fZcEgNODclA3Uddazx7qPnJp8Ivzf4mtpX/b4eXQ6HTHTgoiZFsTa+fG4XC5qGjr770I0o1a0\n0NVrx+WCsrp2yura2bKrAoNeR1q8abCISIsPP2FhLiGEmMpG+/REFGAArMO2WwHldAcrihIHnA9c\nOcrzCg3Q6XRcPfNSGnuaKGkt592yrcQGWVgWlz3u502IDiUhOpSzFyfhdLoot7YPdmccrmqhz+bE\n4XRxpKqVI1WtbP6sDH+jnozEcLJnxrBkZgwh0pUhhJjiJvqRyxuAZuD1sRxskEl9fJ7RGMB3s2/k\nkZ1P0NDVxHsVW1mVtGTC48hImkZG0jS+uno6doeTo9VtFJY1caisieKqVhxOF312J4fKmjlU1szf\n3jvCgswoVs+NY256pEwwdZyBz6V8PrVDcqotnszjaIuGBsABWIZttwB1Izj+G8CLqqraR3leAEwm\neXxOC8yEsDZ1Kf8qeJsOeydmc4i3QyI6Kozl8xMA6OmzU1jaRH5xA7sL6qioa8fmcLKnsJ49hfWY\nQvxZuzCBDYuTmJE4TeaF6CefT+2RnIrhRlU0qKpqUxQlF9gIbIbBgZAbgSe/6FhFUdYB6cBzY4oU\naGvrxuGQQTm+zmDQE2R0N0Zdfd00NXVMugtvakwIqTEhfHVFMuXWdj7Lr2XHISttnX20dfbxxqel\nvPFpKXGRwayeF8eKOXFEhQd6O2yvMBj0mExB8vnUEMmptgzk0xPG0j3xOLCpv3gYeOQyGNgEoCjK\nI0C8qqrXDzvuJtxPXRSONViHwykjeTUiyM99gXW4HPT09eFnmLzjBRKjQrliQwaXrkvnUGkT2w/W\nse9IAza7k9rGLl756Cj//OgoSvI0Vs6JI1uJJihg6k22Kp9P7ZGciuFG3bKpqvoPRVGigIdwd0vk\nAeeqqnqsf5dYIOn4YxRFMQEXA7efWbhCK4L9Pq96exy9k7poGGDQ65mXHsW89Ci6euzkqPXsOFiH\nWtmCCyiqaKGoooU/v6uyKDOalXNimZVqxqCXfmEhhDbINNJiwhmNekq7S/jFtqcAeGD53cQER3s5\nqrFraOlmx6E6th+yYh02M2V4iD/LsyysnBNHUkyolyIcX/JMv/ZITrVFFqwSPm/InQb7yWdv9BVR\n04L46qrpXLAylZLaNrYfrGN3gZXOHjutnX28s7uSd3ZXkhgdyso5sSzPsjAtNMDbYQshxKhJ0SC8\nYmBMA0C3/dRLYfsSnU5Henw46fHhXLUxg/yjjew4WEdecQMOp4uqYx3846NiXtlazKKMaC5YmUpK\nbJi3wxZCiBGTokF4hTkwfPC/8xsOoUTM8GI0nmc06FmUGc2izGg6um3sKbSy/VAdR6vbcLkg9/Ax\ncg8fY156JF9dmUp6Qvjp31QIIbxMigbhFabAMBbHLiCnLo9Pq3eyMXktEYFmb4c1LkKD/Fi/KJH1\nixKxNnWxNa+arftq6LU5yD/aSP7RRmanmvnqylSUZG3+DYQQ2iDDuoXXfDX9HHTosLscbCn9wNvh\nTAhLRDBXbMjg0VtXcMHKFIIC3AtkFZQ188u/7uMXf87lUGkTPjRAWQgxhUjRILwmNiRmcN2JnXU5\n1HcdO80R2hEW7M/X16bz2K0ruWj1dEIC3Tf9Dle18quX8/j5S7nkFTdI8SCEmFSkaBBe9eXUszHo\nDDhdTt4sfc/b4Uy44EA/Llw9nUdvXcml69IJC3bPV1FS08aT/8znJ5v2kKvW45TiQQgxCUjRILwq\nMiiCVfHLAMi17qe6o9bLEXlHUICRLy9P4dFbVnLlxgzCQ/0BqLB28Pt/H+SB53azs6AOp1OKByGE\n90jRILzuvNQN+On9cOHijZJ3vR2OVwX4GzhnSRKP3rKCa8/JJNLkns+huqGTP2wu4Ed/3Mmn+bU4\nnDLhjhBi4smMkGLCnWy2uX8Xv8n7FR8DkB4+neVx2SyMmUeQcWouAjXA7nCy/WAdb+0op76le3D7\nnLQIbr9k3qRYoltmD9Qeyam2eHJGSCkaxIQ7WYPUYevk4V2/prWvbXA/P70f86OzWB67GCViBnqd\n9y+Q3uJwOtldUM8bO8qobXRPVb16XhzfOH+m11cIlQuM9khOtUWKBuHTTtUgtfW1s7Mmh511uVi7\n6occE+5vYmnsIpbFZRMXYpnokCcNu8PJk//M52BpEwAXrZnOhaumezUmucBoj+RUW6RoED7tdA2S\ny+WivL2SXbW55Fjz6LJ3D3k9OSyRZXHZLLYsINQvZKLCnjS6e+384i97qazvAOCmr8xi1dw4r8Uj\nFxjtkZxqixQNwqeNpkGyOe0cbChkV10uhxqLcLo+39+gMzAnahbLYrPJilQw6qfOBKfN7b387MUc\nmtt7Meh13Hn5fGanRnglFrnAaI/kVFukaBA+bawNUntfBznWPHbV5lDZUTPktVC/EBZbFrAsNpuk\nsASv9/NPhMr6Dh75cy49fQ6CAgz88JpsEqMnfvltucBoj+RUW6RoED7NEw1SdUctu2pz2WPdR1tf\n+5DX4kIsLIvNZmnsIsIDTJ4IedI6VNrEb17Zj8PpIsIUwI+uXYw5bGKX3ZYLjPZITrVFigbh0zzZ\nIDmcDoqaj7CrNpf9DYewO+2Dr+nQMSsik/VJq5kdqZxp2JPWp/m1/OmtQgCSY0K584oFhIf4T9j5\n5QKjPZJTbZGiQfi08WqQumzd7K3fz666XEpay4e8dvuCb2lu+e3jvbathM2flQFgNOhYMtPC2YsT\nmR43/nda5AKjPZJTbZGiQfi0iWiQ6rsa2F2Xy9aqz+i295AQGse9S+7Q7FwPLpeLv7x3mA/3Vg/Z\nnhZvYuOiRBbPjMHPOD6/u1xgtEdyqi1SNAifNpEN0rbqnfxd/RcA/zXzksF1LrSqpqGTD/ZWsf1A\nHb02x+B2U4g/Z82PZ93CBI+PeZALjPZITrVFigbh0yayQXI4HfxizxPUdNYR5h/Kg8vvIXAKTE3d\n1WPnswO1fLC3ivrmz+e5MOh1ZCvRbMxOZEZCuEeeMpELjPZITrVFigbh0ya6QSpsPMzv9j8LwLkp\nG7gw/bxxP+dk4XS5OFjSxAe5VRwoaRzyWrIllI3ZiSybZcHfzzDmc8gFRnskp9oiRYPwad5okJ7a\n/ycONRZh1Bu5f9ndRAaZJ+S8k4m1qYsP9lbx2YFauns/77oIDfJjzfw4NixMJDJ89Hdh5AKjPZJT\nbZGiQfg0bzRIdZ1Wfr771zhdTrJj5nPjnKsn5LyTUU+fnR0H63g/t2pw8SsAnQ4WZri7LmYmTxtx\n14VcYLRHcqotUjQIn+atBull9TU+qd4OwPWzr2SxZYFmn6YYCZfLRWF5Mx/kVpFX3MDxTUFCVAgL\nMqJIjw8nLd6E6QvmfZALjPZITrVFigbh07zVIHX0dfLgzl/Sbe8BIDY4hrOTz2JJ7MIptW7FyTS0\ndPPhvmq27a+hs8d+wutR4YGkJ4STFmciLcFEckzY4COccoHRHsmptkjRIHyaNxukQ41F/LXoVVp6\nWwe3TQsIZ33SalbHL5sST1Z8kV6bg10FVnYcrKO0ro0+28nzYzToSLaEkRZvIjNpGgtnxeKvc+Fw\n+Ex7Ir6AFA3aIkWD8GnebpDsTjt76vbxXsXHWLvqB7cHGYNYm7CCdUmrMPmHTXhck43D6aT6WCdH\na9ooqWmlpKZtyBiI4Uwh/u47EfEm0uNNpMaZCAqY2ndwfJW3P6PCs7xeNCiK8l3g+0AssB+4TVXV\nPV+wvz/wAHB1/zE1wEOqqm4axWmlaNCIydIgOV1ODjYU8l7F1iHTThv1RpbHZrMx+SxigqO8Ft9k\n1Nljo7S2jZLqtsFi4mTdGQA6ID46hPR4E2n9YyPiI0PQ67W/AqmvmyyfUeEZXi0aFEW5AngB+Baw\nG7gTuAzIVFW14RTHvA5EAz8CjgJxgF5V1R2jOLUUDRoxGRuk4pZS3ivfysHGwsFtOnQsiJnLOcnr\nSDYlejG6ycvlctHY3ktdSw/5h+s5UtVKVX0HDufJ25VAfwPT++9GpPUXExO5uJYYmcn4GRVj5+2i\nYSewS1XVO/p/1gGVwJOqqj56kv3PA/4KpKmq2nIGsUrRoBGTuUGq6ajj/YqP2WPdh9P1eWyKeQZf\nSlnHTHOGR2ZR1JLh+eyzOSi3tlNS8/ndiKa23lMeHxUe2N+l4b4bkWwJG7d1MsTITObPqBg9rxUN\niqL4AV3AJaqqbj5u+yYgXFXVi09yzO+BDCAXuBboBDYDP1ZVtWcUsUrRoBG+0CA197TwYeU2Pq3Z\nRZ+jb3B7Umg8Z6esY2H0XAz6sc+iqCUjyWdzey8lx42NGNEgy/4nNdLjw4kKD5RibQL5wmdUjJwn\ni4bRjlKKAgyAddh2K6Cc4pg0YA3QA1zU/x5PAxHATaM5ucEg3z60YCCPkzmf0aERXDHra1ww40ts\nrdzOR+XbaLd1UtlRw/OH/srmQDNL4hayNHYhCWFx3g7Xq0aSz2hzENHmIJZlWYDPB1kWV7VytLqV\nozVt1DR0AmB3uPoLjDb3Vw3AHBbAecuS2ZideEZTXouR8YXPqBg5T+ZxtHca4oBqYIWqqruO2/5L\nYK2qqitOcsw7wGrAoqpqR/+2i4FXgBBVVU9933Ion3nMQ2hPn72Pj0p38B/1Peo7h67hkGSKY1XK\nElYlL8YSGu2lCH1fR7eNIxXNqBXNqOXuf+1dfUP2iQwP5MovKZy9NBmjXNCEGA2f6Z7YBKxUVTXz\nuG0zgUO4B08eHeHpXW1t3TgccqvM1xkMekymIHwxnw6ng331B9hRk0NB4+Eh4x4AUk1JLIlbyJLY\nBYQHmLwU5cQar3y6XC7qm7sprmrl/dxKjla3Db4WYw7i62elszzLgl66LTzOlz+j4kT9+ZxUAyEr\ncA+EfOwk+98M/BqIUVW1q3/b14B/AqGjudMg/WvaoJX+0o6+TvYdO0CuNY/illJcx90M06EjY1oa\niy0LWBAzlxC/YC9GOr4mIp8ul4v9xY3865OjVB3rHNyeGB3CxWvTWDAjSsY8eJBWPqPCzdtPT1wO\nbAJu4fNHLi8FZqqqekxRlEeAeFVVr+/fPwQoAHYCD+J+9PKPwEeqqt4yilNL0aARWmyQWnpbybXu\nJ8eaR0V71ZDXDDoDsyIyWWxZwNyo2QQaA7wU5fiYyHw6XS52F1p5bVsp9c3dg9vT4k1csjaNWakR\n43r+qUKLn9GpbDJM7vQd4B7AAuThntwpp/+154EUVVU3HLd/JvBbYBXQCLyM++mJkd5lACkaNEPr\nDVJ917HBAqLuuBknAfz1fsyNmk22ZQGzIxX8NLDmhTfyaXc4+exALZs/K6O5/fNmZFaKma+vTSM9\nIXxC4tAqrX9GpxqvFw1eIkWDRkyVBsnlclHdUUuONY8cax7NvUOnKQkyBrEweg7ZlgVkmtN9dsVN\nb+bTZnfw0b4a3theRke3bXD7ghlRXLw2jaSY0AmNRyumymd0qpCiQfi0qdggOV1OSlsryLHmsbd+\nPx22ziGvm/zDWBQzjyWxC0k1JXspyrGZDPns7rXzfk4lb++uoLvXAbiHii+dbeGiNdOxmLU7pmQ8\nTIacCs+RokH4tKneIDmcDg43HyXHmkfesYP0OIbOcXZF5sWsTTzh6eVJazLls6PbxpZd5XyQU0Vf\nfyyB/gbuv2EJsRFSOIzUZMqpOHNSNAifJg3S52wOG4eaVHKseRxsKMDmtJMQGsd9S+/0dmgjNhnz\n2dLRy5vby/loXzVOl4uNixK5+pzM0x8ogMmZUzF2niwafLMTVQiN8DP4sSB6Dt+ccw0Xz7gAgOqO\nWqyd9ac5UnyRaaEBXH1OJktnxQCw/VAtvX0OL0clhO+TokGISWJB9Fx0/ZO27a3P93I02rBuYQIA\n3b0OdhcOn/1eCDFaUjQIMUmEB4SRMS0NkKLBUzISw4mLdI9l2JpX4+VohPB9UjQIMYkssswDoKaz\njtpO+WZ8pnQ6HesWuO82lNa2UV7X7uWIhPBtUjQIMYkM6aKw7vdyNNqwcm4sfkZ3U/dxXrWXoxHC\nt0nRIMQkEuYfimKeAUBOfR7tfR1ejsj3hQT6sXSme0DkjgLrkEmghBCjI0WDEJPMohh3F0V9VwP3\nfvoQj+z+Df8ufpPCpsP0OeSCNxZn9Q+I7O1z8INntvPX9w9jbe7yclRC+B6Zp0FMOHkG/It123v4\nVe7vTzqmwag3MiN8OjMjMlAiZpAYGu/16ad9IZ8ul4s/vlHAzkOf/011wNz0SM7OTmT29AhZYvs4\nvpBTMXIyuZPwadIgnZ7L5aKms46ipiMUNR3hSEsJNueJdxlC/UJQzDOYGZHBzIgMIgLNEx6rr+TT\n5XJxtKaN93MqyVWP4XB+3vZZIoI5OzuRlXNiCQrw/UXEzpSv5FSMjBQNwqdJgzR6Nqed0tbywSKi\nor0KFyd+dmOCogYLiExzOkHGoHGPzRfz2dzey9Z91WzNq6a96/NiLNDfwOq5cWzMTsQyhaed9sWc\nilOTokH4NGmQzlynrQu1uRi1v4ho6Gk6YR+9Tk9KWNJgETHdlIxBb/B4LL6cT5vdyZ4iK+/nVFE2\n7HHMuWmRbMxOZE7a1Ou68OWcihNJ0SB8mjRIntfQ3UhhfwFxuLmYLnv3CfsEGPzJmJbOzIgMZkVk\nYAmOQeeBi6EW8ulyuSipaeP93CpyiuqHdl2Yg9iQncjquXFTputCCzkVn5OiQfg0aZDGl9PlpLK9\nur+IOExJazkO14nrLkwLCB8yHsLkHzam82ktn83tvXycV83WvBraOvsGtwf4G1g9J44N2QnERYZ4\nMcLxp7WcTnVSNAifJg3SxOp19FHcUkpR02GKmo5Q01l30v0SQuNYYlnIuqTV+OlH/o1aq/m02Z3k\nFNXzfm4lpbVDuy7mpUdy81dnExLo56XoxpdWczpVSdEgfJo0SN7V2tuO2nxkcFBla1/bkNdjgqK4\nLPNrzI5URvR+UyGfR2ta+SC3ij2Fn3ddnLUgnuvPm+nlyMbHVMjpVCJFg/Bp0iBNHi6Xi7queoqa\njpBr3U9pW/ngawui53BJxldP+xjnVMpna0cvz71VyMGSJoICjPzmtlX4GT0/uNTbplJOpwJPFg0y\nI6QQU5hOpyMuxML6pNX8T/Z3uH72lYT5hwKQd+wgD+38X94p+xCb0+7lSCeH8NAAzl+aDEB3r539\nxY1ejkiIiSVFgxACcBcQS2MX8cDyu1mftBq9To/NaWNzyds8vOtxChsPezvESUFJMWMOCwBg+8GT\njw8RQqukaBBCDBFkDOLSjAu5d8kdpIenAlDf3cDv9j/LHw+8RFNPs3cD9DK9TsfyLAsAB0oaaevq\nO80RQmiHFA1CiJNKCI3jzkW3ct2sKwjzG+iyOMBPd/4v75Z9hH0Kd1mszIoFwOF0saew3svRCDFx\npGgQQpySTqdjWVw29y+/m3WJq9Cho89p4/WSLTy8+9cUNk3NLouE6FBSLO55LaSLQkwlhgcffNDb\nMYzUgz09NpxOn3naQ5yCXq8jKMgfyafv8DP4kRU5k3lRWdR01tHc20KnrYvddXvp6OtkceLcKZfP\nPruTg6VNtHT0UlXfQVNbL06Xi9BgP4wG3/4+Jp9RbenP50888V7yyKWYcPI4l29zupzsrtvLa8Vv\n0W7rAOBbi68mO2LhlMpna2cfdz+1Hbtj6O+s1+lIigklLcFEWpyJ9IRwLOYgj0zZPVHkM6otMk+D\n8GnSIGlDp62L/839HfVdDfjpjfxg6W3EBcd5O6wJpVY0s7PAytHqNqobOjhVcxoSaGR6vIn0+HDS\n4k1MjzMRGjR5Z5OUz6i2SNEgfJo0SNpR3VHLYzm/xea0ExMcxT2LbyfIGOjtsLyip89OWW07R2ta\nKalp42hN25C1K4aLjQgmLd5EeryJtPhwEmNCMOgnR7eGfEa1xetFg6Io3wW+D8QC+4HbVFXdc4p9\nzwI+GrbZBcSpqjqaYcdSNGiENEjasrNuDy8VvALAwph53JR1tU/dih8vLpeLxrYeSmra+ouIVsrr\nOk7ozhjg76cn1RJGWkL4YCExMB/ERJPPqLZ4smgY9TqviqJcAfwK+BawG7gTeEdRlExVVRtOcZgL\nyAQGV30ZZcEghJikViUspbyrgk/KdrGvPp9PpqVxVuJKb4fldTqdjqjwIKLCg1g6yz2vg93hpLK+\ng6PVrYPFRH2LexnzPpuTw1WtHK5qHXwPc1jAYAGRFm8iJTaMAD/tTVstfMdYFoe/E/g/VVVfBFAU\n5RbgK8CNwKNfcNwxVVXbvuB1IYQP0ul0fDP7Ko4cK6O208qrR/5DqimJFFOSt0ObdIwGPdPj3GMa\nBrR19Q0WECX9XRs9fe6lzJvbe8lRj5GjHgPAoNeRGO0eZDlQTPjaIEvh20bVPaEoih/QBVyiqurm\n47ZvAsJVVb34JMcMdE+UAYHAQeBBVVW3jzJW6Z7QCLn1qS0D+TxUeZRHdj5Bn9NGZKCZe5fcQbBf\nsLfD8zlOp4vaxs7BcRElNa1UN3SOaJBleryJGYnhBPqP5fvg5+Qzqi3e7J6IAgyAddh2K3CqdXRr\ngW8DOUAAcDOwVVGUpaqq5o3m5AYff/ZZuA3kUfKpDQN5TAqP5+rZl/L8wb/R2NPMq8X/4Rtzr/Jy\ndL4pJc5ESpyJ9dnun7t77ZTWtnG0upWj1W0UV7cODrLs7LFzsKSJgyVNAPgb9SzKjGbF3FjmpkWO\nac4I+YxqiyfzeGbl6AioqnoYOH7auJ2KoqTj7ua4fjTvZTIFeTI04WWST20xmYI4P2stJR2lfFy2\nk911+7g2+2KiQyK9HZrPMwPxseGsWuju8nG5XNQ3d6OWN6FWNKOWN3O0qhW7w0mf3cnOAis7C6yE\nBfuzen48Zy1KZFZqBHr96L5symdUDDfaoqEBcACWYdstwGjmUt0NrBrluWlr68ZxipHHwncYDHpM\npiDJp0YMz+c5iev5pGwXTpeTfx14l8uVC70doib562Buqpm5qWYAbHYnJTVt7CqoY1eBlfYuG+1d\nfWzZUcaWHWVEhQeyPCuWlXNiSYwJ/cL3ls+otgzk0xNGVTSoqmpTFCUX2AhsBlAURdf/85OjeKsF\nuLstRsXhcEr/moZIPrVlIJ/T/M0siJnLvvp8PqvaxfkpGwkyyjfW8aYD0vvnfbh8/QwKy5vZeaiO\nvYL8jqcAACAASURBVIcb6LU5aGjt4Y3tZbyxvYzE6FCWZ1lYNstCZPip59WQz6gYbizdE48Dm/qL\nh4FHLoOBTQCKojwCxKuqen3/z3cApcAh3AMhbwbWA1860+CFEJPTxqS17KvPp8fRy2c1uzk7+Sxv\nhzSlGA165qZFMjctkt4+B3nFDew8VMfB0iYcThdVxzr459YO/rn1KJlJ01g+28LimTGTepZKMTmM\numhQVfUfiqJEAQ/h7pbIA85V1f5ngtwTPh3/rJU/7nkd4nE/eZEPbFRV9ZMzCVwIMXlND08mLTyV\nktYytlZ+xvrE1Rj0Mr+ANwT4G1g228Ky2Rbau/rIUY+x81AdR/rngzhc2cLhyhb+8v/bu/fouM76\n3OPfmZFGmtFdo6vvtmS9vspOYggJIQQCpFAghFJCWiAkTTmBFCinXM5ZbU9C6IJDukhZ9DQ5oaU4\nKVDIKYUSSklKSSAXiBMT2VYSv7JkO77J0uh+l0Yzc/6YsWJdbI/kkfbM1vNZyyvynr01P+XnvefR\nu/d+93+2sH1DiNdtreayTVUOVy2ZStNIy5LT7Vzucq5+NoWb+fsDDwFwy5ab2FVziVMlyhy6+kZ5\n9uXEBZMnw8PTXsv3+7hiey2XNVRiVpdkzPTWsjCOTyPtEIUGl1BocJdz9TMWj/GF3/w1XaPdrCla\nyed2fVKTEGWoE51D/Dp5AWXPwPi014qDubxmczW7TCV1K0uy/rHfy5FCg2Q1hQZ3OV8/nzjxNP+v\n5d8AeNPqq3hv/TvxevShk6li8TitJ/p59uUOnj/YyeBIZNrrgbwctq4vZ0ddiG0bQpQU+B2qVOZD\noUGymkKDu5yvn+PRCe557uucHkk8amZn5XZu3vIB/D5dcJfJcnK8FBYFeHLvMZ4+0E7ToS4m5thX\n19cWsX1DiB31FaytKcKrkaSMpNAgWU2hwV0u1M+hiWEeOLCbw/2vALC+eC23N36EQn/BUpcqKZrZ\n04lIlIPH+tjf1sX+tm66+sdmbVMczE3csVEXYtv6coL5CoaZQqFBsppCg7uk0s+JaIQHX/oeTeED\nAFQGQnx8xx9RFaxYylIlRefraTwep717hP1t3exv6+LQiX6isemfI16Ph/pVJeyoS4SIlRUFup7F\nQQoNktUUGtwl1X7G4jF+2Prv/OL4kwAU5hZwe+MtrC9Zs1SlSorms4+OjE3y0tGeRIg43D31TIyz\nhYrz2F5XQWNdiM1ry/R47yWm0CBZTaHBXebbz8ePP8UPDj1CnDi53lxu2XoTOyq3LUGlkqqF7qOx\neJxjHYPJUYhujpwaYOYnTI7Py6a1pTRuCNFYX0FVqWYLXWwKDZLVFBrcZSH9bAo3s/vF7xKJTeLB\nw/s2vptrVs/7cTSySNK1jw6MTNB8OBEgmg/3MDI+OWudmvIgjXUhGutCNKwu1S2di0ChQbKaQoO7\nLLSfR/pf4f/u381QJDGx0NvWvonr696+WGXKPCzGPhqNxWg7OTA1CnEiPDRrnTy/j+0bQrznqvWs\nqNCFsumi0CBZTaHBXS6mn50jXdy375uER7sB+PxrPsmaolWLUabMw1Lsoz0DY1MB4qVXepiIvPo+\nOT4P11+1nuteu0YjD2mg0CBZTaHBXS62n/3jg9z56/9NJBbhdTW7+NCW9y9ClTIfS72PRiaj2ON9\nNB3q4lf72plMPo57TXUht75jM2uqixa9BjdLZ2hQhBMRR5XkFfHamksBeL6zicGJ2cPW4m65OT62\nrQ/xwbcZvnDra6hfWQLAsY4hvvjg8/zwV4eJ6BeMjKDQICKOu2ZV4iLIydgkT5/a43A14qTaUAH/\n4w8v5aa3bMSf6yUai/PIM0f5wu7naDvV73R5y55Cg4g4bkVhDQ2ldQA8efLXRGNRhysSJ3m9Ht66\nazV3/9HlbF5bBsCprmG+9E97+f4vDjEe0b8Ppyg0iEhGOHPLZd94P03hZoerkUxQVRrgMx/Yyc2/\nY8j3+4jH4dE9x7nzH/dgj/U6Xd6ypNAgIhlhe8UWyvMTv1X+8sTTDlcjmcLj8fDGnSv5q9sup7Eu\nBEBn7yhf+e4L/NNjltE55n6QxeO76667nK4hVXeNjUWIxbLmbg85B6/XQyDgR/10h3T10+PxEI1F\nOdh7iN7xPjqGOxmdHCOYEyCYq1kDl1Im7qOBvBwu31JNdXkQe6yXyGSMo+2DPN3cTt/gOHl+H2VF\neXrGxRyS/fxCOr6XbrmUJadbLt0lnf0cjozwF898iYno9OcXhPLLMWX1mLI6GsrrKfbrFrzFlOn7\naP/wBN95zPK8DU9bXlLo59KGSnY1VNKwphSfV4PpoHkanK5DLlKmH5BkftLdz8P9r/DrU3uwva10\nj8193rq2oBpTVk9DWT0bSzdoJCLNsmUf3dfaxVP72zlwuJuJGXUWBnK5ZGMFuzZVsXlt2bKeJEqh\nQbJathyQJDWL2c+u0R5aeluxyT9zzeHgwcOaolWY8noayuqoK1mH3+dPax3LTbbto+MTUQ4c7uZ5\n28m+tm7GJ6bfXRHIy2FnfQW7TCVb15fjX2ZP2VRokKyWbQckOb+l6mc8Hqd9uIOW3jZsbyuH+toY\nnRybXY/Hx/qStVMjEeuKV+PzLq8PiYuVzftoZDLKi0d62Ws7eeFQ16yHZOXl+misC3GZqaSxLkS+\nP8ehSpeOQoNktWw+IMlsTvUzFo9xfPBkYhSip5W2/qNEYpFZ6/l9fupL1yeviahnZWEtXs/yHapO\nhVv20clojIPHetlrw/y2JczgyPR/H7k5XratL2eXqWJHfYhgfq5DlS4uhQbJam45IElCpvQzEpvk\naP8r2ORIxNGBY8Tis+spyAmysaxu6sLKqmClrrifIVN6mk6xWJyW433stWH2tnTSNzT9Yluf18OW\ndeVcZiq5ZGMFRUH3nOJSaJCs5sYD0nKWqf0cmxynrf8ItreVlp5WTgy1E2f28a40r4SGZIjYVL6R\n0rwSB6rNLJna03SJxeMcPjXAXtvJXhumq3/6aS6vx4NZU8plppJtG0JUlOTjzeJgqdAgWc3tB6Tl\nJlv6ORQZ5lDv4eSFlW10jHTOud7a4tXsrNzGjsptVAcrl7jKzJAtPU2HeDzOsY4hnk8GiNM9I7PW\n8ed4qS4PUhsKUlMepCYUpLa8gJryIHn+zL9eRqFBstpyOiAtB9naz77x/sRFlT2JOzN6x/tmrVNb\nUJ0MENtZVVi7bE5jZGtPL1Y8HudU1zDP2zB7bScnwsMX3Ka8OI/a8iA1oQJqQ8Gpr0sL/Rnz70Wh\nQbLacj0guZUb+hmPxwmPdnGg62Waws0c6X9l1qmMUH45Oyq3srNyO+tL1rj6Yko39DQdOntHOHp6\nkNPdI7T3jCT/O8xE5ML/T/L8PmrPGp2oDRVQEwpSXRYgN2dpRycUGiSr6YDkLm7sZ//4APu7XmRf\n+EVsb+usCyqL/UU0Vm5lZ8U2GsrqXHdLpxt7mi6xeJy+wXHau0do7x7mdM8I7d0jnO4ZoXdw/ILb\nezxQWRKgZipMvBooigK5izI64XhoMMbcAXwGqAH2AZ+w1j6XwnavB54ADlhrL53n2yo0uIQOSO7i\n9n6OREY40PUy+8LNvNTTMuu2zkBOgO0Vm9lZuY3N5Q2umFjK7T1dLKPjk5zuGXk1SHQP094zQkfP\nCJPRC3/WFuTnTF0vURsKTgWLytLARc1o6WhoMMbcCDwIfBTYA3wa+H2gwVrbdZ7tSoC9wCGgWqFh\n+dIByV2WUz/HoxO83G1pCjdzoOtlxqLTr7rP9eayNWTYUbmNbaHNWTu99XLq6VKIxeJ0DYwlQkT3\n9EAxc+6Iufi8HqrKAtMuwjwTKgpSmFvC6dDwG+BZa+2nkn/3AMeBr1tr7znPdv8MtAAx4HqFhuVL\nByR3Wa79nIxN0tLbRlO4mf3hFxmMTJ/i2ufx0VBWx87KbTRWbs2qh2wt1546YWg0khyZGOZ096uj\nFJ29o8RS+HwuDubOugizJhSkojgfrzeRExwLDcaYXGAE+D1r7Y/PWr4bKLHW3nCO7W4B/htwJfCX\nKDQsazoguYv6mZid8nD/K+wLN9MUbqZnxoO2PHjYULKOS6sbuWrF5eR4M3vqYvXUeZPRGOG+0WnX\nTpzuHuFU9wijM6bGnkuOz0tNeYCaUAErKwq47YbGtISG+f7LrQB8QMeM5R2AmWsDY8xG4EvAVdba\nmDFzrpYS3zJ+SpmbnOmj+ukO6ieAl00VdWyqqOP9m97N8cGT/LbjAE2dB2gf7iROnLb+I7T1H+Fw\n/xFua/xgRt99oZ46LyfHy+rqIlZXTx+hisfjDAxPTIWJU90jtHclTnt09Y1O3fMzGY1xIjzMifAw\nzwO33dCYnrrS8l3OwRjjBb4D3GmtbUsuXnDaKS7OzvODMjf1013Uz1eVlxt2rDXA+zg5cJo9J5p4\n6thzHO8/xd6O/aw7+QQ3bn+X02VekHqamcrLYd3q8lnLxyNR2ruGOdE5yInOIU50DHEyPEh79+wJ\nqxZqvqGhC4gC1TOWVwOn51i/CNgF7DTG/F1ymRfwGGMmgLdZa59I9c0HBkaJRjVUlu18Pi/FxQH1\n0yXUz/MLUsQ1tW/gyqrL+epz93N04Dg/eOmnlPhKubx2vmdpl4Z6mr1K8n2UrCll65rSqWXpHDGa\nV2iw1kaMMXuBa4Efw9SFkNcCX59jkwFg24xldwBvAn4PODqf949GYzq/5iLqp7uon+fnJYePbr+Z\ne57/W/rG+3mo+fuU5pZSV7rO6dLOST2VmRZyeuJeYHcyPJy55TII7AYwxnwZWGGtvdlaGwdeOntj\nY0wnMGatffliChcRyTYlecXc3ngL9/72PiaiE3zjwIN8dtcnqAjMHmoWyUTzHrOw1j5MYmKnu4EX\ngEbgOmttOLlKDbA6bRWKiLjI6qIVfGTLTXjwMBQZ5v7932J0ctTpskRSommkZcnpdi53UT8X5ufH\nfskPW/8dgC3lhtsbP5Ix01Grp+6SznkadD+NiIgDrl19NVfWvgaAl3osP2r7qcMViVyYQoOIiAM8\nHg83mhvYWLoBgCdOPM3o5NgFthJxlkKDiIhDcrw5XLvmaiAxq+TgxKDDFYmcn0KDiIiDCnILpr4e\njqRvEh6RxaDQICLioMLc4NTXCg2S6RQaREQcdPZIw1Bk2MFKRC5MoUFExEGBnHw8yUfyaKRBMp1C\ng4iIg7weLwXJUxQaaZBMl9kPdRcRWQYKcoMMRYbZF26mIDdIQ2kdq4pWZPTjs2V5UmgQEXFYZSBE\nx0iYjpHw1CyRgZwA9aXraSiro6G0jhWFNQoR4jiFBhERh33AvJfHjz9FS28rJ4baiRNndHKUA10v\ncaAr8cy/gtwgG0s30FBWT0NZHTXBKjyetMwMLJIyPXtClpzmtXcX9TO9hiMjtPYdpqW3jZbeNk4N\nn55zvSJ/IQ2ldWwsq6OhrI6qQEXaQoR66i7pfPaEQoMsOR2Q3EX9XFyDE0Mc6jvMoWSIOD3SOed6\nJf7ixKmM5J9QfvmCQ4R66i4KDZLVdEByF/VzafWPD3Kor42W3lZaetsIj3bPuV5ZXikmeSqjoayO\nsvzSlN9DPXUXhQbJajoguYv66azesb7EqYy+Ng71ttE91jvnehWBEA2lr45ElOQVn/N7qqfuotAg\nWU0HJHdRPzNL92jPVIho6W2jb7x/zvWqg5WJ6yFK69gSaiCQE5h6TT11F4UGyWo6ILmL+pm54vE4\n4dGuqYsqW/raGJwYmrVeib+IP7vsDkKBckA9dRuFBslqOiC5i/qZPeLxOB0jnVMh4lDf4alZKFcX\nreS/X/px/L5c9dRl0hkaNE+DiMgy4fF4qCmopqagmqtXXUksHuPRo4/zkyOPcnzwJN+z/8qHNr/f\n6TIlg2l6MRGRZcrr8fI7697MjsptADx7ei9PnvyNw1VJJlNoEBFZxjweDx/a/H6qg5UA/MuhH9PW\nd9TZoiRjKTSIiCxzgZx8/nj7h8nz+YnGozyw7yH6Rue+60KWN4UGERGhtqCaD22+EYD+8QHufebv\nicaiDlclmUahQUREALikajtvXXMNAAe72vjuy/96znkeZHnS3RMiIjLlXRuu4/jQSQ72HOKpk8/y\n1MlnqQ5WYcrqaCirZ2PZBgpzC5wuUxyieRpkyekecHdRP91nLDbKffv+kbbeV2a95sHDysJaGsrq\nMGX11JWuJ5CT70CVkipN7iRZTR8y7qJ+uk9OjpfS0iAHTx7lpfChxMOx+toYjozMWtfr8bK2aBUN\nyYdjbShZh9+X60DVci6OhwZjzB3AZ4AaYB/wCWvtc+dY9/XAV4BNQBB4BXjAWvu1eb6tQoNL6EPG\nXdRP95mrp7F4jFNDp2npbcX2ttHad5ix6PjsbT0+1pesTT5hs551xavxeX1L/SPIWRwNDcaYG4EH\ngY8Ce4BPA78PNFhru+ZYfydggP3AMHAV8A3gT621/zCPt1ZocAl9yLiL+uk+qfQ0GotybPDk1CO6\n2/qPEIlNzlrP7/NTX7p+6jHdqwpX4PXoGvyl5HRo+A3wrLX2U8m/e4DjwNettfek+D1+AAxZa2+e\nx1srNLiEPmTcRf10n4X0NBKNcGTg2NRIxNGBY8Tis7cN5gQST9dMXhNRE6zC40nL55mcg2PPnjDG\n5AKXAV86s8xaGzfG/By4IsXvcUly3T+fz3uLiEjmyvXl0pAMA+8ExibHaes/mhyJaOX44CnixBmZ\nHGVfuJl94WYAivyFU6MQpqyeUH65QkQGm+8tlxWAD+iYsbyDxCmIczLGHAcqk9vfZa391jzfW0RE\nskR+Th5bQ4atocRHw0hkhEN9h7G9bbT0ttI+nPgYGZwY4vmOJp7vaAKgPL+MS6saeeeG68j1alaA\nTLOUHbkKKAReB3zFGNNqrf3+fL6Bz6fzYG5wpo/qpzuon+6zGD0tzinkskAjl9U2AolZJ1t62jjY\n04rtaSU82g1Az1gvPz/2Sybjk9y0+Ya0vf9yls4+zjc0dAFRoHrG8mrg9Pk2tNaeueH3RWNMDXAX\nMK/QUFwcmM/qkuHUT3dRP91nMXtaRgHramp5G1cBEB7u5sXOFv6z9Vcc6jnKE8efZueqTVy5Ztei\n1SDzN6/QYK2NGGP2AtcCP4apCyGvBb4+j2/lA/Lm894AAwOjRKO60Crb+XxeiosD6qdLqJ/u40RP\nc8hnR2kjdY11/NWv76V3vJ/793ybMm+ImoKqJanBrc70Mx0WcnriXmB3MjycueUyCOwGMMZ8GVhx\n5s4IY8zHgWPAweT2bwT+DJjvPA1EozFdne0i6qe7qJ/u40RP870Bbt32Qf7mt/czHh3ngaaH+Oyu\nP8Hv8y9pHTK3eZ/osNY+TGJip7uBF4BG4DprbTi5Sg2wesZ7fDm57nPAx4DPWmvvvIi6RUTEpTaU\nrOW99e8E4NTwab5nf0gWzV7sappGWpac7ut3F/XTfTKhp/F4nH9o/jZN4QMA/OGm93Hlitc6Uku2\nS+c8DbrcWUREMo7H4+GDm99HZSAEwPdbfsTxwVMOVyUKDSIikpECOQFu2/Yhcr05TMYmuX/fN3nk\n8KMcHzyp0xUO0ekJWXKZMPQp6aN+uk+m9fSZU3v4zsF/mbYslF/Gjspt7KzczvqSNXqexXk4No20\niIjIUrui9jXk5+TzzKk92N5WYvEY3WO9/OL4k/zi+JMU+4uSAWIbG0s36Kmai0gjDbLkMu23GLk4\n6qf7ZHJPRyKjNHe/TFO4mZe6LZFYZNrrwZwA2yu2sLNyG5vKG/D7ch2qNHM4+pRLByk0uEQmH5Bk\n/tRP98mWno5HJ3i529IUbuZA18uMRcemve73+dka2sTOym1sDW0ikJPvUKXOUmiQrJYtByRJjfrp\nPtnY00hskpbeVpo6m9nf9SJDkeFpr+d4fGwq38iOyu00Vmyh0F/gUKVLT6FBslo2HpDk3NRP98n2\nnkZjUQ73H6Up3ExTuJm+8f5pr3vwsLF0AzuqEtdBlOaVOFTp0lBokKyW7QckmU79dB839TQej3Ns\n8AQvdB6gKXxg6mmaZ1tfvIYdldu4tGoHoUCZA1UuLoUGyWpuOiCJ+ulGbu1pPB6nfbiDpvABmsLN\nnBxqn/a635vLJy/5KOtL1jpU4eLQLZciIiLz5PF4WFFYw4rCGt6x/q2ER7rZ19VMU2czRwZeYSIW\n4UdtP+VPL7kdjyctn7Guo9kwRERkWaoMhnjLmjfymV13cP2GtwPQ2neElt42hyvLXAoNIiKy7F29\n6koKcxN3VPzkyGOapvocFBpERGTZy8/J461rrwHgcP9RDvYccragDKXQICIiAly98gqK/IWARhvO\nRaFBRESExAyS1619MwBHB47xYvdBhyvKPAoNIiIiSa9fcTkl/mIAHjn8KK19RxicGNKoQ5JuuRQR\nEUny+3K5bt2bebjlR5wYOsXf/PZ+AAI5AaqDlVQHK6kKVlKT/G9lsIJc7/L5KF0+P6mIiEgKrlzx\nWvZ2NNHWf3Rq2ejkKEcHjnF04Ni0dT14COWXUVVQORUqzgSLEn+x6+Z70IyQsuTcOtvccqV+uo96\nmjAUGaZzJEzHcJiOkXDi65Ew4dFuovHoBbfP9+VRFaygalqYqKI6WIHf51+CnyBBM0KKiIgsssLc\nAgpLCthQsm7a8mgsSvdY71SIODtQDEwMTq03Fh3n2OBJjg2enPW9y/JKE0GioHJaqCjNK8HrydzL\nDRUaRERE5sHn9SVHECrYxuZpr41OjiaCxHB4WqgIj3YRiU1Ordc73kfveB8He6fPB5HrzaUqWDHt\nNMeZr/Nz8pfk5zsfhQYREZE0CeQEWFe8hnXFa6Ytj8Vj9I71zRqZ6BgJT3t0dyQW4eRQ+6yHaQGU\n+IsTQWLG9RPl+WVLNjqh0CAiIrLIvB4voUA5oUA5W0Jm2mtjk+N0jobpHJ5xumO0i4noxNR6/RMD\n9E8M0NI3/dkYOd4cKgOhWSMT1cFKgrnBtP4cCg0iIiIOys/JY03RKtYUrZq2PB6P0zfeP2tkomMk\nTO9YH3ESNzJMxiZpH+6gfbhj1vcuzC2gpqCKL133ubTUqtAgIiKSgTweD2X5pZTll7KpfOO01yai\nEcKjXVPXT5wdLMaiY1PrDUWGae07kraaFBpERESyjN+Xy8rCWlYW1k5bHo/HGZgYonOkc2pUome8\nN23vq9AgIiLiEh6Ph5K8IkryithYVgck5mlIlwWFBmPMHcBngBpgH/AJa+1z51j3BuBjwE4gD3gR\nuMta+9iCKhYRERFHzDt+GGNuBL4K3AlcQiI0PGqMqTjHJlcDjwFvBy4FHgceMcbsWFDFIiIi4oiF\njDR8GnjAWvsQgDHmduB3gVuBe2aubK399IxFf26MuR54F4nAISIiIllgXiMNxphc4DLgv84ss9bG\ngZ8DV6T4PTxAEdAzn/cWERERZ813pKEC8AEzbwbtAMzs1ef0WaAAeHie743Pl7nzcUvqzvRR/XQH\n9dN91FN3SWcfl/TuCWPMHwB/CbzbWts1z809xcWBRahKnKJ+uov66T7qqcw039DQBUSB6hnLq4HT\n59vQGPMB4BvA+6y1j8/zfUVERMRh8xqzsNZGgL3AtWeWJa9RuBZ45lzbGWNuAr4JfMBa+7OFlSoi\nIiJOWsjpiXuB3caYvcAeEndTBIHdAMaYLwMrrLU3J//+B8nXPgk8Z4w5M0oxaq0duKjqRUREZMnM\n++oIa+3DJCZ2uht4AWgErrPWhpOr1ACrz9rkj0lcPPl3wKmz/nxt4WWLiIjIUvPE43GnaxAREZEs\noPtpREREJCUKDSIiIpIShQYRERFJiUKDiIiIpEShQURERFKi0CAiIiIpWdJnTyyEMeYOEvNC1JB4\nlPYnrLXPOVuVLIQx5k7gzhmLD1prtzhRj8yPMeYNJB44dxlQC7zHWvvjGevcDdwGlAJPAx+z1rYu\nda1yYRfqpzHmW8DNMzb7mbX2HUtXpaTKGPM/gRuATcAoiVmaP2+tbZmx3kXtoxk90mCMuRH4KokP\nmktIhIZHjTEVjhYmF6OZxLNKapJ/rnK2HJmHAqAJ+Dgwa4IXY8zngT8BPgq8Fhgmsb/6l7JISdl5\n+5n0H0zfX29amtJkAd4A/C1wOfAWIBd4zBgz9dSxdOyjmT7S8GngAWvtQwDGmNuB3wVuBe5xsjBZ\nsMmzZg+VLJJ8bszPYOqZMzN9CviitfYnyXU+DHQA7wEeXqo6JTUp9BNgXPtrdpg5AmSM+QjQSWIk\n6ank4oveRzN2pMEYk0vih/2vM8ustXHg58AVTtUlF22jMeakMabNGPNtY8zqC28imc4Ys57Eb6Jn\n768DwLNof81m1xhjOowxB40x9xljyp0uSFJWSmIEqQfSt49mbGgAKkg8s6JjxvIOEj+4ZJ/fAB8B\nrgNuB9YDvzLGFDhZlKRFDYkDlPZX9/gP4MPAm4HPAW8EfnqeUQnJEMkefQ14ylr7UnJxWvbRTD89\nIS5irX30rL82G2P2AK8A7we+5UxVIjKX5MMJz3jRGHMAaAOuAR53pChJ1X3AFuD16f7GmTzS0AVE\nSVyEc7Zq4PTSlyPpZq3tB1qAeqdrkYt2GvCg/dW1rLVHSByXtb9mMGPM/wHeAVxjrW0/66W07KMZ\nGxqstRFgL3DtmWXJIZdrSdxKIlnOGFNI4gDUfqF1JbMlP1BOM31/LSZxJbf2VxcwxqwCQmh/zVjJ\nwHA98CZr7bGzX0vXPprppyfuBXYbY/YCe0jcTREEdjtZlCyMMeavgUdInJJYCXwBiAD/7GRdkprk\ntSf1JH5bAdhgjNkB9Fhrj5M4h/oXxphW4CjwReAE8G8OlCsXcL5+Jv/cCfyAxAdNPfAVEiODj87+\nbuI0Y8x9JG6JfTcwbIw5M6LQb60dS3590ftoRocGa+3DyTkZ7iYxhNIEXKdbgLLWKuC7JH5bCZO4\nDeh11tpuR6uSVO0icS47nvzz1eTyB4FbrbX3GGOCwAMkrtx+Eni7tXbCiWLlgs7Xz48DjSQudpA6\n6wAAAHxJREFUhCwFTpEIC/8rOQosmed2En18YsbyW4CHANKxj3ri8XPN6SEiIiLyqoy9pkFEREQy\ni0KDiIiIpEShQURERFKi0CAiIiIpUWgQERGRlCg0iIiISEoUGkRERCQlCg0iIiKSEoUGERERSYlC\ng4iIiKREoUFERERS8v8B46D7L4r+MbkAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f39cfe4a510>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "survivalstan.utils.plot_observed_survival(df=d[d['sex']=='female'], event_col='event', time_col='t', label='female')\n",
    "survivalstan.utils.plot_observed_survival(df=d[d['sex']=='male'], event_col='event', time_col='t', label='male')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Transform to `long` or `per-timepoint` form"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, since this is a PEM model, we transform our data to `long` or `per-timepoint` form."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO:stancache.stancache:prep_data_long_surv: cache_filename set to prep_data_long_surv.cached.df_17750466280.event_col_event.time_col_t.pkl\n",
      "INFO:stancache.stancache:prep_data_long_surv: Starting execution\n",
      "INFO:stancache.stancache:prep_data_long_surv: Execution completed (0:00:00.388285 elapsed)\n",
      "INFO:stancache.stancache:prep_data_long_surv: Saving results to cache\n"
     ]
    }
   ],
   "source": [
    "dlong = stancache.cached(\n",
    "    survivalstan.prep_data_long_surv,\n",
    "    df=d, event_col='event', time_col='t'\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We now have one record per timepoint (distinct values of `end_time`) per subject (`index`, in the original data frame)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>age</th>\n",
       "      <th>sex</th>\n",
       "      <th>rate</th>\n",
       "      <th>true_t</th>\n",
       "      <th>t</th>\n",
       "      <th>event</th>\n",
       "      <th>index</th>\n",
       "      <th>age_centered</th>\n",
       "      <th>end_time</th>\n",
       "      <th>end_failure</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>133</th>\n",
       "      <td>47</td>\n",
       "      <td>female</td>\n",
       "      <td>0.049787</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>True</td>\n",
       "      <td>1</td>\n",
       "      <td>-8.33</td>\n",
       "      <td>2.394245</td>\n",
       "      <td>False</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>80</th>\n",
       "      <td>47</td>\n",
       "      <td>female</td>\n",
       "      <td>0.049787</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>True</td>\n",
       "      <td>1</td>\n",
       "      <td>-8.33</td>\n",
       "      <td>2.395736</td>\n",
       "      <td>False</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>83</th>\n",
       "      <td>47</td>\n",
       "      <td>female</td>\n",
       "      <td>0.049787</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>True</td>\n",
       "      <td>1</td>\n",
       "      <td>-8.33</td>\n",
       "      <td>2.502706</td>\n",
       "      <td>False</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>125</th>\n",
       "      <td>47</td>\n",
       "      <td>female</td>\n",
       "      <td>0.049787</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>True</td>\n",
       "      <td>1</td>\n",
       "      <td>-8.33</td>\n",
       "      <td>2.549188</td>\n",
       "      <td>False</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>71</th>\n",
       "      <td>47</td>\n",
       "      <td>female</td>\n",
       "      <td>0.049787</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>2.61367</td>\n",
       "      <td>True</td>\n",
       "      <td>1</td>\n",
       "      <td>-8.33</td>\n",
       "      <td>2.613670</td>\n",
       "      <td>True</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "     age     sex      rate   true_t        t event  index  age_centered  \\\n",
       "133   47  female  0.049787  2.61367  2.61367  True      1         -8.33   \n",
       "80    47  female  0.049787  2.61367  2.61367  True      1         -8.33   \n",
       "83    47  female  0.049787  2.61367  2.61367  True      1         -8.33   \n",
       "125   47  female  0.049787  2.61367  2.61367  True      1         -8.33   \n",
       "71    47  female  0.049787  2.61367  2.61367  True      1         -8.33   \n",
       "\n",
       "     end_time end_failure  \n",
       "133  2.394245       False  \n",
       "80   2.395736       False  \n",
       "83   2.502706       False  \n",
       "125  2.549188       False  \n",
       "71   2.613670        True  "
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dlong.query('index == 1').sort_values('end_time').tail()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Fit stan model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, we are ready to fit our model using `survivalstan.fit_stan_survival_model`. \n",
    "\n",
    "We pass a few parameters to the fit function, many of which are required. See ?survivalstan.fit_stan_survival_model for details. \n",
    "\n",
    "Similar to what we did above, we are asking `survivalstan` to cache this model fit object. See [stancache](http://github.com/jburos/stancache) for more details on how this works. Also, if you didn't want to use the cache, you could omit the parameter `FIT_FUN` and `survivalstan` would use the standard pystan functionality.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "testfit = survivalstan.fit_stan_survival_model(\n",
    "    model_cohort = 'test model',\n",
    "    model_code = survivalstan.models.pem_survival_model,\n",
    "    df = dlong,\n",
    "    sample_col = 'index',\n",
    "    timepoint_end_col = 'end_time',\n",
    "    event_col = 'end_failure',\n",
    "    formula = '~ age_centered + sex',\n",
    "    iter = 5000,\n",
    "    chains = 4,\n",
    "    seed = 9001,\n",
    "    FIT_FUN = stancache.cached_stan_fit,\n",
    "    )\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Superficial review of convergence\n",
    "\n",
    "We will note here some top-level summaries of posterior draws -- this is a minimal example so it's unlikely that this model converged very well. \n",
    "\n",
    "In practice, you would want to do a lot more investigation of convergence issues, etc. For now the goal is to demonstrate the functionalities available here."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can summarize posterior estimates for a single parameter, (e.g. the built-in Stan parameter `lp__`):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "survivalstan.utils.print_stan_summary([testfit], pars='lp__')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Or, for sets of parameters with the same name:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "survivalstan.utils.print_stan_summary([testfit], pars='log_baseline_raw')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It's also not uncommon to graphically summarize the `Rhat` values, to get a sense of similarity among the chains for particular parameters.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "survivalstan.utils.plot_stan_summary([testfit], pars='log_baseline_raw')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Plot posterior estimates of parameters"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can use `plot_coefs` to summarize posterior estimates of parameters. \n",
    "\n",
    "In this basic `pem_survival_model`, we estimate a parameter for baseline hazard for each observed timepoint which is then adjusted for the duration of the timepoint.  For consistency, the baseline values are normalized to the *unit time* given in the input data. This allows us to compare hazard estimates across timepoints without having to know the duration of a timepoint. *(in general, the duration-adjusted hazard paramters are suffixed with `_raw` whereas those which are unit-normalized do not have a suffix).*\n",
    "\n",
    "In this model, the baseline hazard is parameterized by two components -- there is an overall mean across all timepoints (`log_baseline_mu`) and some variance per timepoint (`log_baseline_tp`). The degree of variance is estimated from the data as `log_baseline_sigma`. All components have weak default priors. See the stan code above for details.\n",
    "\n",
    "In this case, the model estimates a minimal degree of variance across timepoints, which is good given that the simulated data assumed a constant hazard over time. \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "survivalstan.utils.plot_coefs([testfit], element='baseline')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also summarize the posterior estimates for our `beta` coefficients. This is actually the default behavior of `plot_coefs`. Here we hope to see the posterior estimates of beta coefficients include the value we used for our simulation (0.5)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "survivalstan.utils.plot_coefs([testfit])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Posterior predictive checking\n",
    "\n",
    "Finally, `survivalstan` provides some utilities for posterior predictive checking.\n",
    "\n",
    "The goal of posterior-predictive checking is to compare the uncertainty of model predictions to observed values.\n",
    "\n",
    "We are not doing *true* out-of-sample predictions, but we are able to sanity-check our model's calibration. We expect approximately 5% of observed values to fall outside of their corresponding 95% posterior-predicted intervals.\n",
    "\n",
    "By default, `survivalstan`'s plot_pp_survival method will plot whiskers at the 2.5th and 97.5th percentile values, corresponding to 95% predicted intervals."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "survivalstan.utils.plot_pp_survival([testfit], fill=False)\n",
    "survivalstan.utils.plot_observed_survival(df=d, event_col='event', time_col='t', color='green', label='observed')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also summarize and plot survival by our covariates of interest, provided they are included in the original dataframe provided to `fit_stan_survival_model`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "survivalstan.utils.plot_pp_survival([testfit], by='sex')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This plot can also be customized by a variety of aesthetic elements"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "survivalstan.utils.plot_pp_survival([testfit], by='sex', pal=['red', 'blue'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Building up the plot semi-manually, for more customization"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also access the utility methods within `survivalstan.utils` to more or less produce the same plot. This sequence is intended to both illustrate how the above-described plot was constructed, and expose some of the \n",
    "functionality in a more concrete fashion.\n",
    "\n",
    "Probably the most useful element is being able to summarize & return posterior-predicted values to begin with:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "ppsurv = survivalstan.utils.prep_pp_survival_data([testfit], by='sex')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here are what these data look like:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "ppsurv.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(Note that this itself is a summary of the posterior draws returned by `survivalstan.utils.prep_pp_data`. In this case, the survival stats are summarized by values of `['iter', 'model_cohort', by]`. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can then call out to `survivalstan.utils._plot_pp_survival_data` to construct the plot. In this case, we overlay the posterior predicted intervals with observed values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "subplot = plt.subplots(1, 1)\n",
    "survivalstan.utils._plot_pp_survival_data(ppsurv.query('sex == \"male\"').copy(),\n",
    "                                          subplot=subplot, color='blue', alpha=0.5)\n",
    "survivalstan.utils._plot_pp_survival_data(ppsurv.query('sex == \"female\"').copy(),\n",
    "                                          subplot=subplot, color='red', alpha=0.5)\n",
    "survivalstan.utils.plot_observed_survival(df=d[d['sex']=='female'], event_col='event', time_col='t',\n",
    "                                          color='red', label='female')\n",
    "survivalstan.utils.plot_observed_survival(df=d[d['sex']=='male'], event_col='event', time_col='t',\n",
    "                                          color='blue', label='male')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "## Use plotly to summarize posterior predicted values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First, we will precompute 50th and 95th posterior intervals for each observed timepoint, by group."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "ppsummary = ppsurv.groupby(['sex','event_time'])['survival'].agg({\n",
    "        '95_lower': lambda x: np.percentile(x, 2.5),\n",
    "        '95_upper': lambda x: np.percentile(x, 97.5),\n",
    "        '50_lower': lambda x: np.percentile(x, 25),\n",
    "        '50_upper': lambda x: np.percentile(x, 75),\n",
    "        'median': lambda x: np.percentile(x, 50),\n",
    "    }).reset_index()\n",
    "shade_colors = dict(male='rgba(0, 128, 128, {})', female='rgba(214, 12, 140, {})')\n",
    "line_colors = dict(male='rgb(0, 128, 128)', female='rgb(214, 12, 140)')\n",
    "ppsummary.sort_values(['sex', 'event_time'], inplace=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, we construct our graph \"traces\", consisting of 3 elements (solid line and two shaded areas) per observed group."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import plotly\n",
    "import plotly.plotly as py\n",
    "import plotly.graph_objs as go\n",
    "plotly.offline.init_notebook_mode(connected=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "data5 = list()\n",
    "for grp, grp_df in ppsummary.groupby('sex'):\n",
    "    x = list(grp_df['event_time'].values)\n",
    "    x_rev = x[::-1]\n",
    "    y_upper = list(grp_df['50_upper'].values)\n",
    "    y_lower = list(grp_df['50_lower'].values)\n",
    "    y_lower = y_lower[::-1]\n",
    "    y2_upper = list(grp_df['95_upper'].values)\n",
    "    y2_lower = list(grp_df['95_lower'].values)\n",
    "    y2_lower = y2_lower[::-1]\n",
    "    y = list(grp_df['median'].values)\n",
    "    my_shading50 = go.Scatter(\n",
    "        x = x + x_rev,\n",
    "        y = y_upper + y_lower,\n",
    "        fill = 'tozerox',\n",
    "        fillcolor = shade_colors[grp].format(0.3),\n",
    "        line = go.Line(color = 'transparent'),\n",
    "        showlegend = True,\n",
    "        name = '{} - 50% CI'.format(grp),\n",
    "    )\n",
    "    my_shading95 = go.Scatter(\n",
    "        x = x + x_rev,\n",
    "        y = y2_upper + y2_lower,\n",
    "        fill = 'tozerox',\n",
    "        fillcolor = shade_colors[grp].format(0.1),\n",
    "        line = go.Line(color = 'transparent'),\n",
    "        showlegend = True,\n",
    "        name = '{} - 95% CI'.format(grp),\n",
    "    )\n",
    "    my_line = go.Scatter(\n",
    "        x = x,\n",
    "        y = y,\n",
    "        line = go.Line(color=line_colors[grp]),\n",
    "        mode = 'lines',\n",
    "        name = grp,\n",
    "    )\n",
    "    data5.append(my_line)    \n",
    "    data5.append(my_shading50)\n",
    "    data5.append(my_shading95)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, we build a minimal layout structure to house our graph:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "layout5 = go.Layout(\n",
    "    yaxis=dict(\n",
    "        title='Survival (%)',\n",
    "        #zeroline=False,\n",
    "        tickformat='.0%',\n",
    "    ),\n",
    "    xaxis=dict(title='Days since enrollment')\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here is our plot:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "py.iplot(go.Figure(data=data5, layout=layout5), filename='survivalstan/pem_survival_model_ppsummary')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Note: this plot will not render in github, since github disables iframes. You can however view it in nbviewer or on plotly's website directly*"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "celltoolbar": "Edit Metadata",
  "kernelspec": {
   "display_name": "Python [conda env:newbladder2]",
   "language": "python",
   "name": "conda-env-newbladder2-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
